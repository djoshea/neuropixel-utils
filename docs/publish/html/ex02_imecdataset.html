<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB 2020b"><title>About ImecDataset</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.8px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: 400; text-align: left;  }
.S1 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.S2 { margin: 20px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: 700; text-align: left;  }
.CodeBlock { background-color: #F7F7F7; margin: 10px 0 10px 0;}
.S3 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 0px none rgb(0, 0, 0); border-radius: 4px 4px 0px 0px; padding: 6px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S4 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 0px 0px 4px 4px; padding: 0px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S5 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 4px 4px 0px 0px; padding: 6px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S6 { color: rgb(64, 64, 64); padding: 10px 0px 6px 17px; background: rgb(255, 255, 255) none repeat scroll 0% 0% / auto padding-box border-box; font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px; overflow-x: hidden; line-height: 17.234px;  }
.embeddedOutputsErrorElement {min-height: 18px; max-height: 250px; overflow: auto;}
.embeddedOutputsErrorElement.inlineElement {}
.embeddedOutputsErrorElement.rightPaneElement {}
.embeddedOutputsWarningElement{min-height: 18px; max-height: 250px; overflow: auto;}
.embeddedOutputsWarningElement.inlineElement {}
.embeddedOutputsWarningElement.rightPaneElement {}
.diagnosticMessage-wrapper {font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 12px;}
.diagnosticMessage-wrapper.diagnosticMessage-warningType {color: rgb(255,100,0);}
.diagnosticMessage-wrapper.diagnosticMessage-warningType a {color: rgb(255,100,0); text-decoration: underline;}
.diagnosticMessage-wrapper.diagnosticMessage-errorType {color: rgb(230,0,0);}
.diagnosticMessage-wrapper.diagnosticMessage-errorType a {color: rgb(230,0,0); text-decoration: underline;}
.diagnosticMessage-wrapper .diagnosticMessage-messagePart,.diagnosticMessage-wrapper .diagnosticMessage-causePart {white-space: pre-wrap;}
.diagnosticMessage-wrapper .diagnosticMessage-stackPart {white-space: pre;}
.embeddedOutputsTextElement,.embeddedOutputsVariableStringElement {white-space: pre; word-wrap: initial; min-height: 18px; max-height: 250px; overflow: auto;}
.textElement,.rtcDataTipElement .textElement {padding-top: 3px;}
.embeddedOutputsTextElement.inlineElement,.embeddedOutputsVariableStringElement.inlineElement {}
.inlineElement .textElement {}
.embeddedOutputsTextElement.rightPaneElement,.embeddedOutputsVariableStringElement.rightPaneElement {min-height: 16px;}
.rightPaneElement .textElement {padding-top: 2px; padding-left: 9px;}
.S7 { margin: 10px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.S8 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 4px; padding: 6px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S9 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: 700; text-align: left;  }
.S10 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 0px none rgb(0, 0, 0); border-radius: 0px; padding: 0px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S11 { margin: 10px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 15px; font-weight: 700; text-align: left;  }
.S12 { margin: 10px 0px 20px; padding-left: 0px; font-family: Helvetica, Arial, sans-serif; font-size: 14px;  }
.S13 { margin-left: 56px; line-height: 21px; min-height: 0px; text-align: left; white-space: pre-wrap;  }
.S14 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: 700; text-align: left;  }
.S15 { border-left: 0px none rgb(0, 0, 0); border-right: 0px none rgb(0, 0, 0); border-top: 0px none rgb(0, 0, 0); border-bottom: 0px none rgb(0, 0, 0); border-radius: 0px; padding: 0px; line-height: 16px; min-height: 16px; white-space: pre; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 12px;  }</style></head><body><div class = rtcContent><h1  class = 'S0'><span>About ImecDataset</span></h1><div  class = 'S1'><span>The </span><span style=' font-family: monospace;'>npxutils.ImecDataset</span><span> class wraps one individual recording session acquired with SpikeGLX. Currently, four files with extensions </span><span style=' font-family: monospace;'>.imec.ap.bin</span><span>, </span><span style=' font-family: monospace;'>.imec.ap.meta</span><span>, </span><span style=' font-family: monospace;'>.imec.lf.bin</span><span>, and </span><span style=' font-family: monospace;'>.imec.lf.meta</span><span> comprise one ImecDataset.</span></div><h2  class = 'S2'><span>Data setup</span></h2><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>homeDir = string(java.lang.System.getProperty(</span><span style="color: rgb(170, 4, 249);">'user.home'</span><span>));</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>exDataDir = homeDir + </span><span style="color: rgb(170, 4, 249);">'work/npxutils/example-data'</span><span>;</span></span></div></div></div><h2  class = 'S2'><span>Constructing an ImecDataset</span></h2><div  class = 'S1'><span>You construct a npxutils.ImecDataset by pointing it at the path to your dataset. How you specify the path is flexible. You can point directly at one of the files:</span></div><div class="CodeBlock"><div class="inlineWrapper outputs"><div  class = 'S5'><span style="white-space: pre;"><span>imec = npxutils.ImecDataset(exDataDir + </span><span style="color: rgb(170, 4, 249);">'/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin'</span><span>);</span></span></div><div  class = 'S6'><div class="inlineElement eoOutputWrapper embeddedOutputsErrorElement" uid="F1E54B1B" data-scroll-top="null" data-scroll-left="null" data-width="1128" data-height="30" data-hashorizontaloverflow="false" data-testid="output_0" style="max-height: 261px; width: 1158px;"><div class="diagnosticMessage-wrapper diagnosticMessage-errorType"><div class="diagnosticMessage-messagePart">Error using npxutils.ImecDataset (line 173)<br>No AP or LF Imec file found at or in /Users/jankework/npxutils/example-data/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin</div><div class="diagnosticMessage-stackPart"></div></div></div></div></div></div><div  class = 'S7'><span>Or specify the common prefix to the </span><span style=' font-family: monospace;'>.imec.*</span><span> files comprising the dataset:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>imecB = npxutils.ImecDataset(exDataDir + </span><span style="color: rgb(170, 4, 249);">'/raw_datasets/neuropixel_01_g0_t0'</span><span>);</span></span></div></div></div><div  class = 'S7'><span>The common prefix can be shorter as long as there is no ambiguity:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>imecC = npxutils.ImecDataset(exDataDir + </span><span style="color: rgb(170, 4, 249);">'/raw_datasets/neuropixel_01'</span><span>);</span></span></div></div></div><div  class = 'S7'><span>You can also point at the parent directory as long as only one </span><span style=' font-family: monospace;'>.ap.bin</span><span> file is contained within:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>imecD = npxutils.ImecDataset(exDataDir + </span><span style="color: rgb(170, 4, 249);">'/data/raw_datasets/'</span><span>);</span></span></div></div></div><div  class = 'S7'><span>These are all equivalent, in that the resulting </span><span style=' font-family: monospace;'>imec</span><span> instance will wrap both AP and LF bin and meta files. (Though it’s okay if the LF files are missing).</span></div><h3  class = 'S9'><span>Specifying a Channel Map</span></h3><div  class = 'S1'><span>When constructing the ImecDataset, you can specify a channel map. If you don’t specify one, the default will be returned by</span><span> </span><span style=' font-family: monospace;'>npxutils.util.getDefaultChannelMapFile()</span><span>, which in turn will look for the file pointed to by the environment variables</span><span> </span><span style=' font-family: monospace;'>'NEUROPIXEL_MAP_FILE'</span><span> </span><span>or</span><span> </span><span style=' font-family: monospace;'>'NPIX_MAP_FILE'</span><span>. You can set these using Matlab’s</span><span> </span><span style=' font-family: monospace;'>setenv</span><span> </span><span>function.</span></div><div  class = 'S1'><span>These .mat files are expected to be in the same format as found on the</span><span> </span><a href = "https://github.com/cortex-lab/neuropixels"><span>neuropixels repo</span></a><span>. For the phase 3A probe with 384 channels, the file</span><span> </span><span style=' font-family: monospace;'>neuropixPhase3A_kilosortChanMap.mat</span><span> </span><span>contains:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>ld = load(</span><span style="color: rgb(170, 4, 249);">'neuropixPhase3A_kilosortChanMap.mat'</span><span>)</span></span></div></div></div><div  class = 'S7'><span>You can construct a ChannelMap directly by pointing at the </span><span style=' font-family: monospace;'>.mat</span><span> file, although every function within </span><span style=' font-family: monospace;'>neuropixel-utils</span><span> will also accept the filename and construct the </span><span style=' font-family: monospace;'>ChannelMap</span><span> for you:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>probeName = </span><span style="color: rgb(170, 4, 249);">'neuropixPhase3B1'</span><span>;</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>probeMatFilePath = npxutils.globals.distroot + </span><span style="color: rgb(170, 4, 249);">'/map_files/' </span><span>+ probeName + </span><span style="color: rgb(170, 4, 249);">'_kilosortChanMap.mat'</span><span>;</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>chanMapObject = npxutils.ChannelMap(probeMatFilePath)</span></span></div></div></div><div  class = 'S7'><span>Then you can use this map for an ImecDataset using either of the following:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>imecE = npxutils.ImecDataset(</span><span style="color: rgb(170, 4, 249);">'channelMap'</span><span>, chanMapObject);</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>imecF = npxutils.ImecDataset(</span><span style="color: rgb(170, 4, 249);">'channelMap'</span><span>, probeMatFilePath);</span></span></div></div></div><h2  class = 'S2'><span>Exploring metadata</span></h2><div  class = 'S1'><span>When the ImecDataset is created, the metadata are loaded from the </span><span style=' font-family: monospace;'>.ap.meta</span><span> file. You can request the full metadata using:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>meta = imec.readAPMeta()</span></span></div></div></div><div  class = 'S7'><span>The most commonly accessed metadata is stored in properties of the ImecDataset:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>disp(imec)</span></span></div></div></div><h3  class = 'S9'><span>Setting sync bit names</span></h3><div  class = 'S1'><span>For convenience, if you use the sync bits for individual TTL signals during your recordings, you can set their names for the recording so that subsequent processing can refer to the bits by name rather than index. You may also find it useful to store additional data in some sync bits during subsequent processing, such as marking regions of time where an artifact was detected, such that specifying the bit by name is useful. Bits are ordered like </span><span style=' font-family: monospace;'>bitget</span><span>, i.e. 1 is the least significant bit.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>imec.setSyncBitNames(1, </span><span style="color: rgb(170, 4, 249);">"trialStart"</span><span>);</span></span></div></div></div><div  class = 'S7'><span>The full set of sync bits is found in </span><span style=' font-family: monospace;'>imec.syncBitNames</span><span>, or you can lookup the bit corresponding to a given name using:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>idx = imec.lookupSyncBitByName(</span><span style="color: rgb(170, 4, 249);">"trialStart"</span><span>);</span></span></div></div></div><h3  class = 'S9'><span>Marking bad channels</span></h3><div  class = 'S1'><span>You can manually mark specific channels as bad using the </span><span style=' font-family: monospace;'>markBadChannels</span><span> function and passing a list of IDs to it:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>channelIds = [17 23 52];</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>imec.markBadChannels(channelIds);</span></span></div></div></div><h4  class = 'S11'><span>WARNING: Use channel IDs, not indices</span></h4><div  class = 'S1'><span>Note that like all channel lists,</span><span> </span><span style=' font-family: monospace;'>channelIds</span><span> </span><span>is specified using the actual unique ids of each channel (as specified in the ChannelMap), which is not necessarily their index into the channel map if the channels are not contiguously numbered.</span></div><div  class = 'S1'><span>You can use</span><span> </span><span style=' font-family: monospace;'>lookup_channelIds</span><span> </span><span>to find the channel indices for a given set of channel ids if needed:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>[channelInds, channelIds] = imec.lookup_channelIds(channelIds)</span></span></div></div></div><div  class = 'S7'><span>One common task is marking channels as bad if their RMS voltage lies outside a reasonable range:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>goodRmsRange = [3 100]; </span><span style="color: rgb(2, 128, 9);">% [low high] range of RMS in uV</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>imec.markBadChannelsByRMS(</span><span style="color: rgb(170, 4, 249);">'rmsRange'</span><span>, goodRmsRange);</span></span></div></div></div><div  class = 'S7'><span>The remaining “good” channel ids can always be accessed using </span><span style=' font-family: monospace;'>imec.goodChannels</span><span> which will be the set of connected channels excluding the bad channels.</span></div><h3  class = 'S9'><span>Writing modified metadata back to disk</span></h3><div  class = 'S1'><span>After making any modifications to the metadata, such as setting the sync bit names or marking bad channels, you can write it back to disk (in the </span><span style=' font-family: monospace;'>.imec.ap.meta</span><span> file) such that it will be reloaded automatically the next time you create an ImecDataset instance for that file.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>imec.writeModifiedAPMeta();</span></span></div></div></div><div  class = 'S7'><span>You can also append whatever fields you want to the meta file using the </span><span style=' font-family: monospace;'>extraMeta</span><span> parameter:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>extraMeta.cleaned = true;</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>extraMeta.cleaningAlgorithm = </span><span style="color: rgb(170, 4, 249);">'v1'</span><span>;</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>imec.writeModifiedAPMeta(</span><span style="color: rgb(170, 4, 249);">'extraMeta'</span><span>, extraMeta);</span></span></div></div></div><h2  class = 'S2'><span>Accessing data</span></h2><h3  class = 'S9'><span>Raw memory maps</span></h3><div  class = 'S1'><span>The most convenient way to access the data is to request a memory map:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>mmap = imec.memmapAP_full();</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>value = mmap.Data.x(ch_index, sample_index) </span><span style="color: rgb(2, 128, 9);">% access a specific sample</span></span></div></div></div><div  class = 'S7'><span>Equivalent functionality is available for LF files using </span><span style=' font-family: monospace;'>imec.memmapLF_full()</span><span>. If you wish to modify the underlying data file directly, you can also request a Writeable version of the memory map:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>mmap = imec.memmapAP_full(</span><span style="color: rgb(170, 4, 249);">'Writiable'</span><span>, true);</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>mmap.Data.x(ch_index, sample_index) = new_value; </span><span style="color: rgb(2, 128, 9);">% overwrite a specific sample</span></span></div></div></div><h3  class = 'S9'><span>Reading specific time window</span></h3><div  class = 'S1'><span>You can also request a specific sample or time window directly:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>idxWindow = [idxFirst idxLast];</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>[partialData, sampleIdx] = imec.readAP_idx(idxWindow);</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>timeWindow = [secStart, secStop]; </span><span style="color: rgb(2, 128, 9);">% in seconds</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>[partialDataB, sampleIdxB] = imec.readAP_timeWindow(timeWindow);</span></span></div></div></div><h3  class = 'S9'><span>Plotting specific time windows</span></h3><div  class = 'S1'><span>You can also quickly generate a stacked traces plot of a specific time window, optionally selecting which channels to plot. Take care to select a reasonable time window to avoid overwhelming your system. All channels are individually centered and then collectively normalized by the maximum value before plotting. You can change the global scaling factor by specifying </span><span style=' font-family: monospace;'>gain</span><span> &gt; 1.</span></div><div  class = 'S1'><span style=' font-family: monospace;'>imec</span><span style=' font-family: monospace;'>.</span><span style=' font-family: monospace;'>inspectAP_idxWindow</span><span style=' font-family: monospace;'>(</span><span style=' font-family: monospace;'>idxWindow</span><span style=' font-family: monospace;'>,</span><span style=' font-family: monospace;'> </span><span style=' font-family: monospace;'>...</span><span style=' font-family: monospace;'>)</span></div><div  class = 'S1'><span style=' font-family: monospace;'>imec</span><span style=' font-family: monospace;'>.</span><span style=' font-family: monospace;'>inspectAP_timeWindow</span><span style=' font-family: monospace;'>(</span><span style=' font-family: monospace;'>timeWindow</span><span style=' font-family: monospace;'>,</span><span style=' font-family: monospace;'> </span><span style=' font-family: monospace;'>...</span><span style=' font-family: monospace;'>)</span></div><div  class = 'S1'><span>There are additional optional parameters you can specify:</span></div><ul  class = 'S12'><li  class = 'S13'><span style=' font-family: monospace;'>channels</span><span>: channel indices to plot, defaults to</span><span> </span><span style=' font-family: monospace;'>imec.mappedChannels</span></li><li  class = 'S13'><span style=' font-family: monospace;'>syncBits</span><span> </span><span>: which sync bits to plot individually, defaults to</span><span> </span><span style=' font-family: monospace;'>imec.syncBitsNamed</span></li><li  class = 'S13'><span style=' font-family: monospace;'>gain</span><span>: global scaling factor, values larger then 1 will magnify the individual channels, defaults to 0.95</span></li><li  class = 'S13'><span style=' font-family: monospace;'>car</span><span>: perform common average referencing before plotting, defaults to false</span></li><li  class = 'S13'><span style=' font-family: monospace;'>downsample</span><span> </span><span>: take every nth sample to speed up plotting, defaults to 1</span></li></ul><div  class = 'S1'><span>Good channels are plotted in black, non-connected channels in blue, and bad channels in red. Sync bits are also shown in red and are not affected by the normalization gain.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% TODO: Some code that actually generates a plot here!</span></span></div></div></div><h3  class = 'S9'><span>Reading sync channel</span></h3><div  class = 'S1'><span>You can access the sync channel all at once using:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>sync = imec.readSync();</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>trialStartBit = imec.readSyncBit(</span><span style="color: rgb(170, 4, 249);">"trialStart"</span><span>);</span></span></div></div></div><div  class = 'S7'><span>Or a specific sample or time window using:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>[partialSync, sampleIdx] = imec.readSync_idx(idxWindow);</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>[partialSyncB, sampleIdxB] = imec.readSync_timeWindow(timeWindow);</span></span></div></div></div><div  class = 'S7'><span>You can also access the logical values of specific bits either by bit index or name using:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>partial = imec.readSyncBits_idx(bits_or_names, idxWindow); </span><span style="color: rgb(2, 128, 9);">%  nTime x nBits</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>trialStart_partial = imec.readSyncBits_idx(</span><span style="color: rgb(170, 4, 249);">"trialStart"</span><span>, idxWindow); </span><span style="color: rgb(2, 128, 9);">% nTime x 1</span></span></div></div></div><h2  class = 'S14'><span>Building a preprocessing pipeline</span></h2><div  class = 'S1'><span>If the raw </span><span style=' font-family: monospace;'>.imec.ap.bin</span><span> file must be processed in some way before running Kilosort, e.g. to remove artifacts, you can implement this efficiently by writing a transformation function that will act on chunks of the data. One example is found in </span><span style=' font-family: monospace;'>Neuropixel.DataProcessFn.commonAverageReference</span><span>:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">function </span><span>[data, extra] = commonAverageReference(imec, data, chIds, sampleIdx) </span><span style="color: rgb(2, 128, 9);">%#ok&lt;INUSD&gt;</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>    </span><span style="color: rgb(2, 128, 9);">% chIds are the channel ids and imec.goodChannels is a list of channel ids</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>    </span><span style="color: rgb(2, 128, 9);">% so this will lookup the channel indices of those channels both in chIdx that</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>    </span><span style="color: rgb(2, 128, 9);">% are also marked as good. This prevents us from computing the reference</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>    </span><span style="color: rgb(2, 128, 9);">% from the sync, reference, or bad channels.</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>    chanMask = imec.lookup_channelIds(intersect(chIds, imec.goodChannels));</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>    </span><span style="color: rgb(2, 128, 9);">% subtract median of each channel over time</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>    data(chanMask, :) = bsxfun(@minus, data(chanMask, :), median(data(chanMask, :), 2));</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>    </span><span style="color: rgb(2, 128, 9);">% subtract median across good channels</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>    data(chanMask, :) = bsxfun(@minus, data(chanMask, :), median(data(chanMask, :), 1));</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><div  class = 'S7'><span>Essentially, your transform function can perform any modifications to the data matrix and return the resulting data matrix. Here, </span><span style=' font-family: monospace;'>imec</span><span> will be the ImecDataset being transformed, </span><span style=' font-family: monospace;'>data</span><span> will be the </span><span style=' font-family: monospace;'>nChannels x nTime</span><span> chunk of data being processed. </span><span style=' font-family: monospace;'>chIds</span><span> will be the channel ids (not necessarily their indices into data but the ids assigned by the channel map), and will typically be the full list of channel ids present in the data file. </span><span style=' font-family: monospace;'>sampleIdx</span><span> is the sample indices in the current chunk. </span><span style=' font-family: monospace;'>extra</span><span> is an optional output argument that allows you to store any additional metadata. After the transformation function has been run on every chunk of the dataset, these individual </span><span style=' font-family: monospace;'>extra</span><span> outputs will be accumulated in a cell array by chunk.</span></div><h3  class = 'S9'><span>Modifying a dataset during copy to new location</span></h3><div  class = 'S1'><span>Once you’ve written your transform function (or functions), you can run them on the dataset using:</span></div><div class = 'preformatted-matlab' style = 'margin: 10px 3px 10px 55px; padding: 10px 10px 10px 5px; '><div  class = 'S15'><span style="white-space: pre;"><span>imecOut = imec.saveTransformedDataset(outPath, </span><span style="color: rgb(170, 4, 249);">'transformAP'</span><span>, </span><span style="color: rgb(14, 0, 255);">...</span><span style="color: rgb(2, 128, 9);">\</span></span></div><div  class = 'S15'><span style="white-space: pre;"><span>  {cell of </span><span style="color: rgb(14, 0, 255);">function </span><span>handles}, </span><span style="color: rgb(170, 4, 249);">'transformLF'</span><span>, {cell of </span><span style="color: rgb(14, 0, 255);">function </span><span>handles});</span></span></div></div><div  class = 'S1'><span>Here, </span><span style=' font-family: monospace;'>outPath</span><span> should include the folder where the new datasets should be written. By default, the file stem (preceeding </span><span style=' font-family: monospace;'>.ap.bin</span><span>) will match the leaf directory in </span><span style=' font-family: monospace;'>outPath</span><span>, but this can be specified manually by passing a </span><span style=' font-family: monospace;'>stem</span><span> parameter:</span></div><div class = 'preformatted-matlab' style = 'margin: 10px 3px 10px 55px; padding: 10px 10px 10px 5px; '><div  class = 'S15'><span style="white-space: pre;"><span>imecOut = imec.saveTransformedDataset(</span><span style="color: rgb(170, 4, 249);">'/path/to/datasets'</span><span>, </span><span style="color: rgb(170, 4, 249);">'stem'</span><span>, </span><span style="color: rgb(170, 4, 249);">'modifiedDataset'</span><span>, </span><span style="color: rgb(14, 0, 255);">...</span><span style="color: rgb(2, 128, 9);">)</span></span></div><div  class = 'S15'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% creates /path/to/datasets/modifiedDataset.ap.bin, .ap.meta, etc.</span></span></div></div><div  class = 'S1'><span>You can provide one or more function handles (e.g.</span><span> </span><span style=' font-family: monospace;'>@Neuropixel.DataProcessFn.commonAverageReference</span><span>) that will be applied sequentially. Other optional parameters include:</span></div><ul  class = 'S12'><li  class = 'S13'><span style=' font-family: monospace;'>dryRun</span><span>: if true, no actual data will be modified on disk, facilitating testing or step by step debugging of the transform functions before writing data. (default false)</span></li><li  class = 'S13'><span style=' font-family: monospace;'>gpuArray</span><span>: if true, the data chunks will be copied to the GPU and the transformation functions will receive and return GPU arrays</span></li><li  class = 'S13'><span style=' font-family: monospace;'>applyScaling</span><span>: if true, the data will be converted to floating point values with the correct analog scale. if false (default) the data will remain in the original, unscaled</span><span> </span><span style=' font-family: monospace;'>int16</span><span> </span><span>quantization.</span></li><li  class = 'S13'><span style=' font-family: monospace;'>writeAP</span><span>: if true, the AP file will be transformed and copied</span></li><li  class = 'S13'><span style=' font-family: monospace;'>writeLF</span><span>: if true, the LF file will be transformed and copied (default false but will be set true automatically if any transformLF is non-empty)</span></li><li  class = 'S13'><span style=' font-family: monospace;'>goodChannelsOnly</span><span>: send only the channels marked good to the transform function</span></li><li  class = 'S13'><span style=' font-family: monospace;'>connectedChannelsOnly</span><span>: send only the connected channels to the transform function</span></li><li  class = 'S13'><span style=' font-family: monospace;'>mappedChannelsOnly</span><span>: send only the mapped channels to the transform function</span></li><li  class = 'S13'><span style=' font-family: monospace;'>chunkSize</span><span>: specify the number of time samples sent to transform functions at once</span></li><li  class = 'S13'><span style=' font-family: monospace;'>extraMeta</span><span>: a struct with extra meta fields to include or overwrite with the output file</span></li><li  class = 'S13'><span style=' font-family: monospace;'>timeShifts</span><span>: a</span><span> </span><span style=' font-family: monospace;'>Neuropixel.TimeShiftSpec</span><span> </span><span>instance used to excise time windows, see</span><span> </span><a href = "https://djoshea.github.io/neuropixel-utils/imec_dataset/#excising-time-windows"><span>excising time windows</span></a></li></ul><h4  class = 'S11'><span>WARNING: Save transformed data to a new folder!</span></h4><div  class = 'S1'><span>Ensure that </span><span style=' font-family: monospace;'>outPath</span><span> refers to separate directory so that you make a copy of the dataset rather than writing over the same location. An error will be thrown if any existing files would be overwritten by this call.</span></div><h3  class = 'S9'><span>Modifying a dataset in place</span></h3><div  class = 'S1'><span>Rather than generate a copy, you can also modify a file in place if you’re short on disk space, but be careful, as there’s no undo if anything goes wrong. The same additional parameters are accepted, and you may wish to test your code first by passing </span><span style=' font-family: monospace;'>'dryRun', true</span><span>.</span></div><div class = 'preformatted-matlab' style = 'margin: 10px 3px 10px 55px; padding: 10px 10px 10px 5px; '><div  class = 'S15'><span style="white-space: pre;"><span>imec.modifyAPInPlace(outPath, {cell of </span><span style="color: rgb(14, 0, 255);">function </span><span>handles}, </span><span style="color: rgb(14, 0, 255);">...</span><span style="color: rgb(2, 128, 9);">);</span></span></div><div  class = 'S15'><span style="white-space: pre;"><span>imec.modifyLFInPlace(outPath, {cell of </span><span style="color: rgb(14, 0, 255);">function </span><span>handles}, </span><span style="color: rgb(14, 0, 255);">...</span><span style="color: rgb(2, 128, 9);">);</span></span></div></div><h3  class = 'S9'><span>Concatenating multiple files together</span></h3><div  class = 'S1'><span>If you have multiple separate recording files that you wish to process and sort together, you can concatenate them together during the copy. The code will also scale the datasets up to a common gain factor if the file gains differ from each other. This will not of course increase the resolution of low-gain files, but it will ensure that the signal amplitudes match across files with different gains.</span></div><div class = 'preformatted-matlab' style = 'margin: 10px 3px 10px 55px; padding: 10px 10px 10px 5px; '><div  class = 'S15'><span style="white-space: pre;"><span>imecList = {imec1, imec2, </span><span style="color: rgb(14, 0, 255);">...</span><span style="color: rgb(2, 128, 9);">};</span></span></div><div  class = 'S15'><span style="white-space: pre;"><span>imecOut = npxutils.ImecDataset.writeConcatenatedFileMatchGains(imecList, outPath, </span><span style="color: rgb(14, 0, 255);">...</span></span></div><div  class = 'S15'><span style="white-space: pre;"><span>        </span><span style="color: rgb(170, 4, 249);">'transformAP'</span><span>, {cell of </span><span style="color: rgb(14, 0, 255);">function </span><span>handles}, </span><span style="color: rgb(14, 0, 255);">...</span></span></div><div  class = 'S15'><span style="white-space: pre;"><span>        </span><span style="color: rgb(170, 4, 249);">'transformLF'</span><span>, {cell of </span><span style="color: rgb(14, 0, 255);">function </span><span>handles}, </span><span style="color: rgb(14, 0, 255);">...</span><span style="color: rgb(2, 128, 9);">);</span></span></div></div><h2  class = 'S2'><span>Making copies and symbolic links</span></h2><div  class = 'S1'><span>You can generate a copy of a dataset using:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>[imecOut] = imec.saveTransformedDataset(outPath, </span><span style="color: rgb(170, 4, 249);">'writeAP'</span><span>, true, </span><span style="color: rgb(170, 4, 249);">'writeLF'</span><span>, true);</span></span></div></div></div><div  class = 'S7'><span>Alternatively, you can create symbolic links to the AP bin and meta files in a new location using:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>imecLinked = imec.symLinkAPIntoDirectory(outPath);</span></span></div></div></div><div  class = 'S7'><span>This is useful for running Kilosort with varying parameters, since each run would ideally live in its own directory but there’s no need for a real copy of the raw data.</span></div><h3  class = 'S9'><span>Excising time windows</span></h3><div  class = 'S1'><span>Occasionally it can be beneficial to remove certain time windows from a file, or to omit them while plotting data. This may be accomplished using </span><span style=' font-family: monospace;'>npxutils.TimeShiftSpec</span><span> instances to indicate which windows of time to keep and how to shift them so as to remove gaps. A </span><span style=' font-family: monospace;'>TimeShiftSpec</span><span> specifies a list of sample intervals bounded by a start and stop index in properties </span><span style=' font-family: monospace;'>idxStart</span><span> and </span><span style=' font-family: monospace;'>idxStop</span><span>. The start index in </span><span style=' font-family: monospace;'>idxStart</span><span> will be shifted to lie at sample index </span><span style=' font-family: monospace;'>idxShiftStart</span><span>. You can calculate these shifts directly, but it is typically easier to specify only the sample intervals you wish to keep and then construct the </span><span style=' font-family: monospace;'>TimeShiftSpec</span><span> using:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>timeShifts = npxutils.TimeShiftSpec.buildToExciseGaps(idxStartList, idxStopList);</span></span></div></div></div><div  class = 'S7'><span>If you have known trial boundaries in your file (see</span><span> Segmenting a Kilosort dataset into trials </span><span>for more information), you can also excise the regions of time far from trial boundaries using the</span><span> </span><span style=' font-family: monospace;'>TrialSegmentationInfo</span><span> </span><span>instance. I’ve found this to be useful to exclude time windows where the subject was asleep from further analysis.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>timeShifts = tsi.computeShiftsExciseRegionsOutsideTrials(</span><span style="color: rgb(170, 4, 249);">'maxPauseSec'</span><span>, 20);</span></span></div></div></div><div  class = 'S7'><span>You can then pass along this </span><span style=' font-family: monospace;'>npxutils.TimeShiftSpec</span><span> to any of the data transform functions. Depending on whether the </span><span style=' font-family: monospace;'>timeShifts</span><span> object was created in indices of </span><span style=' font-family: monospace;'>AP</span><span> band sample rate or </span><span style=' font-family: monospace;'>LF</span><span> band sample rate, you should pass it along as </span><span style=' font-family: monospace;'>timeShiftsAP</span><span> or </span><span style=' font-family: monospace;'>timeShiftsLF</span><span>. The conversion to the other sampling rate will be handled automatically so that the excision is performed on both datasets appropriately.</span></div><div class = 'preformatted-matlab' style = 'margin: 10px 3px 10px 55px; padding: 10px 10px 10px 5px; '><div  class = 'S15'><span style="white-space: pre;"><span>imecOut = imec.saveTransformedDataset(outPath, </span><span style="color: rgb(170, 4, 249);">'timeShiftsAP'</span><span>, timeShifts, </span><span style="color: rgb(14, 0, 255);">...</span><span style="color: rgb(2, 128, 9);">);</span></span></div></div><div  class = 'S1'><span>A cell array of </span><span style=' font-family: monospace;'>npxutils.TimeShiftSpec</span><span> instances can be provided when concatenating multiple files:</span></div><div class = 'preformatted-matlab' style = 'margin: 10px 3px 10px 55px; padding: 10px 10px 10px 5px; '><div  class = 'S15'><span style="white-space: pre;"><span> imecOut = npxutils.ImecDataset.writeConcatenatedFileMatchGains(outPath, imecList, </span><span style="color: rgb(14, 0, 255);">...</span></span></div><div  class = 'S15'><span style="white-space: pre;"><span>        </span><span style="color: rgb(170, 4, 249);">'timeShiftsAP'</span><span>, {timeShift1, timeShift2, </span><span style="color: rgb(14, 0, 255);">...</span><span style="color: rgb(2, 128, 9);"> }, ...);</span></span></div></div><h3  class = 'S9'><span>Referring to Source Datasets</span></h3><div  class = 'S1'><span>If helpful, when loading a derived </span><span style=' font-family: monospace;'>ImecDataset</span><span>, you can specify the </span><span style=' font-family: monospace;'>sourceDatasets</span><span> parameter to provide an array of </span><span style=' font-family: monospace;'>ImecDataset</span><span> instances corresponding to the original, pre-processed source datasets. Here, this would be the set of raw datasets provided as the </span><span style=' font-family: monospace;'>imecList</span><span> argument above. For certain methods, you can then pass parameter </span><span style=' font-family: monospace;'>fromSourceDatasets</span><span>, true and the corresponding window of time from the source datasets will be plotted instead of the processed data. This will automatically handle any time shifts and excisions performed; consequently it is helpful for debugging processing pipelines to see the before and after data.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>imecProcessed = npxutils.ImecDataset.writeConcatenatedFileMatchGains(outPath, imecList);</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% ... or:</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre;"><span>imecProcessedB = npxutils.ImecDataset(outPath, </span><span style="color: rgb(170, 4, 249);">'sourceDatasets'</span><span>, {imecRaw1, imecRaw2});</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>imecProcessed.inspectAP_timeWindow([1 2], </span><span style="color: rgb(170, 4, 249);">'fromSourceDatasets'</span><span>, true);</span></span></div></div></div><div  class = 'S7'><span></span></div><div  class = 'S1'></div></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% About ImecDataset
% The |npxutils.ImecDataset| class wraps one individual recording session acquired 
% with SpikeGLX. Currently, four files with extensions |.imec.ap.bin|, |.imec.ap.meta|, 
% |.imec.lf.bin|, and |.imec.lf.meta| comprise one ImecDataset.
%% Data setup

homeDir = string(java.lang.System.getProperty('user.home'));
exDataDir = homeDir + 'work/npxutils/example-data';
%% Constructing an ImecDataset
% You construct a npxutils.ImecDataset by pointing it at the path to your dataset. 
% How you specify the path is flexible. You can point directly at one of the files:

imec = npxutils.ImecDataset(exDataDir + '/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin');
%% 
% Or specify the common prefix to the |.imec.*| files comprising the dataset:

imecB = npxutils.ImecDataset(exDataDir + '/raw_datasets/neuropixel_01_g0_t0');
%% 
% The common prefix can be shorter as long as there is no ambiguity:

imecC = npxutils.ImecDataset(exDataDir + '/raw_datasets/neuropixel_01');
%% 
% You can also point at the parent directory as long as only one |.ap.bin| file 
% is contained within:

imecD = npxutils.ImecDataset(exDataDir + '/data/raw_datasets/');
%% 
% These are all equivalent, in that the resulting |imec| instance will wrap 
% both AP and LF bin and meta files. (Though it’s okay if the LF files are missing).
% Specifying a Channel Map
% When constructing the ImecDataset, you can specify a channel map. If you don’t 
% specify one, the default will be returned by |npxutils.util.getDefaultChannelMapFile()|, 
% which in turn will look for the file pointed to by the environment variables 
% |'NEUROPIXEL_MAP_FILE'| or |'NPIX_MAP_FILE'|. You can set these using Matlab’s 
% |setenv| function.
% 
% These .mat files are expected to be in the same format as found on the <https://github.com/cortex-lab/neuropixels 
% neuropixels repo>. For the phase 3A probe with 384 channels, the file |neuropixPhase3A_kilosortChanMap.mat| 
% contains:

ld = load('neuropixPhase3A_kilosortChanMap.mat')
%% 
% You can construct a ChannelMap directly by pointing at the |.mat| file, although 
% every function within |neuropixel-utils| will also accept the filename and construct 
% the |ChannelMap| for you:

probeName = 'neuropixPhase3B1';
probeMatFilePath = npxutils.globals.distroot + '/map_files/' + probeName + '_kilosortChanMap.mat';
chanMapObject = npxutils.ChannelMap(probeMatFilePath)
%% 
% Then you can use this map for an ImecDataset using either of the following:

imecE = npxutils.ImecDataset('channelMap', chanMapObject);
imecF = npxutils.ImecDataset('channelMap', probeMatFilePath);
%% Exploring metadata
% When the ImecDataset is created, the metadata are loaded from the |.ap.meta| 
% file. You can request the full metadata using:

meta = imec.readAPMeta()
%% 
% The most commonly accessed metadata is stored in properties of the ImecDataset:

disp(imec)
% Setting sync bit names
% For convenience, if you use the sync bits for individual TTL signals during 
% your recordings, you can set their names for the recording so that subsequent 
% processing can refer to the bits by name rather than index. You may also find 
% it useful to store additional data in some sync bits during subsequent processing, 
% such as marking regions of time where an artifact was detected, such that specifying 
% the bit by name is useful. Bits are ordered like |bitget|, i.e. 1 is the least 
% significant bit.

imec.setSyncBitNames(1, "trialStart");
%% 
% The full set of sync bits is found in |imec.syncBitNames|, or you can lookup 
% the bit corresponding to a given name using:

idx = imec.lookupSyncBitByName("trialStart");
% Marking bad channels
% You can manually mark specific channels as bad using the |markBadChannels| 
% function and passing a list of IDs to it:

channelIds = [17 23 52];
imec.markBadChannels(channelIds);
% WARNING: Use channel IDs, not indices
% Note that like all channel lists, |channelIds| is specified using the actual 
% unique ids of each channel (as specified in the ChannelMap), which is not necessarily 
% their index into the channel map if the channels are not contiguously numbered.
% 
% You can use |lookup_channelIds| to find the channel indices for a given set 
% of channel ids if needed:

[channelInds, channelIds] = imec.lookup_channelIds(channelIds)
%% 
% One common task is marking channels as bad if their RMS voltage lies outside 
% a reasonable range:

goodRmsRange = [3 100]; % [low high] range of RMS in uV
imec.markBadChannelsByRMS('rmsRange', goodRmsRange);
%% 
% The remaining “good” channel ids can always be accessed using |imec.goodChannels| 
% which will be the set of connected channels excluding the bad channels.
% Writing modified metadata back to disk
% After making any modifications to the metadata, such as setting the sync bit 
% names or marking bad channels, you can write it back to disk (in the |.imec.ap.meta| 
% file) such that it will be reloaded automatically the next time you create an 
% ImecDataset instance for that file.

imec.writeModifiedAPMeta();
%% 
% You can also append whatever fields you want to the meta file using the |extraMeta| 
% parameter:

extraMeta.cleaned = true;
extraMeta.cleaningAlgorithm = 'v1';
imec.writeModifiedAPMeta('extraMeta', extraMeta);
%% Accessing data
% Raw memory maps
% The most convenient way to access the data is to request a memory map:

mmap = imec.memmapAP_full();
value = mmap.Data.x(ch_index, sample_index) % access a specific sample
%% 
% Equivalent functionality is available for LF files using |imec.memmapLF_full()|. 
% If you wish to modify the underlying data file directly, you can also request 
% a Writeable version of the memory map:

mmap = imec.memmapAP_full('Writiable', true);
mmap.Data.x(ch_index, sample_index) = new_value; % overwrite a specific sample
% Reading specific time window
% You can also request a specific sample or time window directly:

idxWindow = [idxFirst idxLast];
[partialData, sampleIdx] = imec.readAP_idx(idxWindow);

timeWindow = [secStart, secStop]; % in seconds
[partialDataB, sampleIdxB] = imec.readAP_timeWindow(timeWindow);
% Plotting specific time windows
% You can also quickly generate a stacked traces plot of a specific time window, 
% optionally selecting which channels to plot. Take care to select a reasonable 
% time window to avoid overwhelming your system. All channels are individually 
% centered and then collectively normalized by the maximum value before plotting. 
% You can change the global scaling factor by specifying |gain| > 1.
% 
% |imec.inspectAP_idxWindow(idxWindow, ...)|
% 
% |imec.inspectAP_timeWindow(timeWindow, ...)|
% 
% There are additional optional parameters you can specify:
%% 
% * |channels|: channel indices to plot, defaults to |imec.mappedChannels|
% * |syncBits| : which sync bits to plot individually, defaults to |imec.syncBitsNamed|
% * |gain|: global scaling factor, values larger then 1 will magnify the individual 
% channels, defaults to 0.95
% * |car|: perform common average referencing before plotting, defaults to false
% * |downsample| : take every nth sample to speed up plotting, defaults to 1
%% 
% Good channels are plotted in black, non-connected channels in blue, and bad 
% channels in red. Sync bits are also shown in red and are not affected by the 
% normalization gain.

% TODO: Some code that actually generates a plot here!
% Reading sync channel
% You can access the sync channel all at once using:

sync = imec.readSync();
trialStartBit = imec.readSyncBit("trialStart");
%% 
% Or a specific sample or time window using:

[partialSync, sampleIdx] = imec.readSync_idx(idxWindow);
[partialSyncB, sampleIdxB] = imec.readSync_timeWindow(timeWindow);
%% 
% You can also access the logical values of specific bits either by bit index 
% or name using:

partial = imec.readSyncBits_idx(bits_or_names, idxWindow); %  nTime x nBits
trialStart_partial = imec.readSyncBits_idx("trialStart", idxWindow); % nTime x 1
%% Building a preprocessing pipeline
% If the raw |.imec.ap.bin| file must be processed in some way before running 
% Kilosort, e.g. to remove artifacts, you can implement this efficiently by writing 
% a transformation function that will act on chunks of the data. One example is 
% found in |Neuropixel.DataProcessFn.commonAverageReference|:

function [data, extra] = commonAverageReference(imec, data, chIds, sampleIdx) %#ok<INUSD>
    % chIds are the channel ids and imec.goodChannels is a list of channel ids
    % so this will lookup the channel indices of those channels both in chIdx that
    % are also marked as good. This prevents us from computing the reference
    % from the sync, reference, or bad channels.
    chanMask = imec.lookup_channelIds(intersect(chIds, imec.goodChannels));

    % subtract median of each channel over time
    data(chanMask, :) = bsxfun(@minus, data(chanMask, :), median(data(chanMask, :), 2));

    % subtract median across good channels
    data(chanMask, :) = bsxfun(@minus, data(chanMask, :), median(data(chanMask, :), 1));
end
%% 
% Essentially, your transform function can perform any modifications to the 
% data matrix and return the resulting data matrix. Here, |imec| will be the ImecDataset 
% being transformed, |data| will be the |nChannels x nTime| chunk of data being 
% processed. |chIds| will be the channel ids (not necessarily their indices into 
% data but the ids assigned by the channel map), and will typically be the full 
% list of channel ids present in the data file. |sampleIdx| is the sample indices 
% in the current chunk. |extra| is an optional output argument that allows you 
% to store any additional metadata. After the transformation function has been 
% run on every chunk of the dataset, these individual |extra| outputs will be 
% accumulated in a cell array by chunk.
% Modifying a dataset during copy to new location
% Once you’ve written your transform function (or functions), you can run them 
% on the dataset using:
%%
% 
%   imecOut = imec.saveTransformedDataset(outPath, 'transformAP', ...\
%     {cell of function handles}, 'transformLF', {cell of function handles});
%
%% 
% Here, |outPath| should include the folder where the new datasets should be 
% written. By default, the file stem (preceeding |.ap.bin|) will match the leaf 
% directory in |outPath|, but this can be specified manually by passing a |stem| 
% parameter:
%%
% 
%   imecOut = imec.saveTransformedDataset('/path/to/datasets', 'stem', 'modifiedDataset', ...)
%   % creates /path/to/datasets/modifiedDataset.ap.bin, .ap.meta, etc.
%
%% 
% You can provide one or more function handles (e.g. |@Neuropixel.DataProcessFn.commonAverageReference|) 
% that will be applied sequentially. Other optional parameters include:
%% 
% * |dryRun|: if true, no actual data will be modified on disk, facilitating 
% testing or step by step debugging of the transform functions before writing 
% data. (default false)
% * |gpuArray|: if true, the data chunks will be copied to the GPU and the transformation 
% functions will receive and return GPU arrays
% * |applyScaling|: if true, the data will be converted to floating point values 
% with the correct analog scale. if false (default) the data will remain in the 
% original, unscaled |int16| quantization.
% * |writeAP|: if true, the AP file will be transformed and copied
% * |writeLF|: if true, the LF file will be transformed and copied (default 
% false but will be set true automatically if any transformLF is non-empty)
% * |goodChannelsOnly|: send only the channels marked good to the transform 
% function
% * |connectedChannelsOnly|: send only the connected channels to the transform 
% function
% * |mappedChannelsOnly|: send only the mapped channels to the transform function
% * |chunkSize|: specify the number of time samples sent to transform functions 
% at once
% * |extraMeta|: a struct with extra meta fields to include or overwrite with 
% the output file
% * |timeShifts|: a |Neuropixel.TimeShiftSpec| instance used to excise time 
% windows, see <https://djoshea.github.io/neuropixel-utils/imec_dataset/#excising-time-windows 
% excising time windows>
% WARNING: Save transformed data to a new folder!
% Ensure that |outPath| refers to separate directory so that you make a copy 
% of the dataset rather than writing over the same location. An error will be 
% thrown if any existing files would be overwritten by this call.
% Modifying a dataset in place
% Rather than generate a copy, you can also modify a file in place if you’re 
% short on disk space, but be careful, as there’s no undo if anything goes wrong. 
% The same additional parameters are accepted, and you may wish to test your code 
% first by passing |'dryRun', true|.
%%
% 
%   imec.modifyAPInPlace(outPath, {cell of function handles}, ...);
%   imec.modifyLFInPlace(outPath, {cell of function handles}, ...);
%
% Concatenating multiple files together
% If you have multiple separate recording files that you wish to process and 
% sort together, you can concatenate them together during the copy. The code will 
% also scale the datasets up to a common gain factor if the file gains differ 
% from each other. This will not of course increase the resolution of low-gain 
% files, but it will ensure that the signal amplitudes match across files with 
% different gains.
%%
% 
%   imecList = {imec1, imec2, ...};
%   imecOut = npxutils.ImecDataset.writeConcatenatedFileMatchGains(imecList, outPath, ...
%           'transformAP', {cell of function handles}, ...
%           'transformLF', {cell of function handles}, ...);
%
%% Making copies and symbolic links
% You can generate a copy of a dataset using:

[imecOut] = imec.saveTransformedDataset(outPath, 'writeAP', true, 'writeLF', true);
%% 
% Alternatively, you can create symbolic links to the AP bin and meta files 
% in a new location using:

imecLinked = imec.symLinkAPIntoDirectory(outPath);
%% 
% This is useful for running Kilosort with varying parameters, since each run 
% would ideally live in its own directory but there’s no need for a real copy 
% of the raw data.
% Excising time windows
% Occasionally it can be beneficial to remove certain time windows from a file, 
% or to omit them while plotting data. This may be accomplished using |npxutils.TimeShiftSpec| 
% instances to indicate which windows of time to keep and how to shift them so 
% as to remove gaps. A |TimeShiftSpec| specifies a list of sample intervals bounded 
% by a start and stop index in properties |idxStart| and |idxStop|. The start 
% index in |idxStart| will be shifted to lie at sample index |idxShiftStart|. 
% You can calculate these shifts directly, but it is typically easier to specify 
% only the sample intervals you wish to keep and then construct the |TimeShiftSpec| 
% using:

timeShifts = npxutils.TimeShiftSpec.buildToExciseGaps(idxStartList, idxStopList);
%% 
% If you have known trial boundaries in your file (see Segmenting a Kilosort 
% dataset into trials for more information), you can also excise the regions of 
% time far from trial boundaries using the |TrialSegmentationInfo| instance. I’ve 
% found this to be useful to exclude time windows where the subject was asleep 
% from further analysis.

timeShifts = tsi.computeShiftsExciseRegionsOutsideTrials('maxPauseSec', 20);
%% 
% You can then pass along this |npxutils.TimeShiftSpec| to any of the data transform 
% functions. Depending on whether the |timeShifts| object was created in indices 
% of |AP| band sample rate or |LF| band sample rate, you should pass it along 
% as |timeShiftsAP| or |timeShiftsLF|. The conversion to the other sampling rate 
% will be handled automatically so that the excision is performed on both datasets 
% appropriately.
%%
% 
%   imecOut = imec.saveTransformedDataset(outPath, 'timeShiftsAP', timeShifts, ...);
%
%% 
% A cell array of |npxutils.TimeShiftSpec| instances can be provided when concatenating 
% multiple files:
%%
% 
%    imecOut = npxutils.ImecDataset.writeConcatenatedFileMatchGains(outPath, imecList, ...
%           'timeShiftsAP', {timeShift1, timeShift2, ... }, ...);
%
% Referring to Source Datasets
% If helpful, when loading a derived |ImecDataset|, you can specify the |sourceDatasets| 
% parameter to provide an array of |ImecDataset| instances corresponding to the 
% original, pre-processed source datasets. Here, this would be the set of raw 
% datasets provided as the |imecList| argument above. For certain methods, you 
% can then pass parameter |fromSourceDatasets|, true and the corresponding window 
% of time from the source datasets will be plotted instead of the processed data. 
% This will automatically handle any time shifts and excisions performed; consequently 
% it is helpful for debugging processing pipelines to see the before and after 
% data.

imecProcessed = npxutils.ImecDataset.writeConcatenatedFileMatchGains(outPath, imecList);
% ... or:
imecProcessedB = npxutils.ImecDataset(outPath, 'sourceDatasets', {imecRaw1, imecRaw2});

imecProcessed.inspectAP_timeWindow([1 2], 'fromSourceDatasets', true);
%% 
% 
% 
%
##### SOURCE END #####
--></body></html>