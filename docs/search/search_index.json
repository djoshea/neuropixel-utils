{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"MATLAB Neuropixel Utilites \u00b6 Neuropixel Utils is a toolkit written in Matlab for manipulating datasets collected by SpikeGLX (e.g. imec.ap.bin files) and the results produced by Kilosort / Kilosort 2 . Please note that some of this functionality is redundant with the tools found in the Cortex Lab\u2019s spikes repository , authored By Nick Steinmetz, Mush Okun, and others. Here, we prioritize an organized, easy to use, object-oriented approach to accessing, manipulating, and visualizing the data. This reduces the need to worry about metadata. Neuropixel Utils facilitates the following data processing steps: Load and visualize raw neuropixel data from imec.ap.bin and imec.lf.bin files in Matlab. Write custom pre-processing functions to apply to raw data either by writing a copy of the raw file or modifying it in place, optionally removing specific problematic time windows in the file. Concatenate multiple Imec data files together while matching the amplifier gains. Run Kilosort/Kilosort2 , and load the results back into Matlab after manual inspection in Phy. Plot drift maps using code adapted from the spikes repository . Extract waveforms for each cluster from the raw data, optionally cleaning the snippets by subtracting templates for other clusters spiking during the same time window. Visualize cluster electrical spiking images in space and cluster locations on the probe . Determine trial boundaries in the file, and efficiently segment Kilosort results into individual trials . Neuropixel Utils was authored by Daniel J O\u2019Shea ( @djoshea ) to facilitate precision artifact removal and careful inspection of raw data traces before running Kilosort, as well as post-hoc verification that the artifacts were removed successfully. Download and install \u00b6 To get started, clone the repo: git clone https://github.com/djoshea/neuropixel-utils.git And add it to your path in Matlab: >> addpath ( '/path/to/neuropixel-utils' ) Example walkthrough \u00b6 % Create an ImecDataset pointing at a specific >> channelMapFile = 'neuropixPhase3A_kilosortChanMap.mat' ; >> imec = npxutils . ImecDataset ( '/data/raw_datasets/neuropixel_01.imec.ap.bin' , 'channelMap' , channelMapFile ); ImecDataset with properties: pathRoot : '/data/raw_datasets' fileStem : 'neuropixel_01' creationTime : 7.3722e+05 nChannels : 385 fileTypeAP : 'ap' nSamplesAP : 112412208 nSamplesLF : 0 fsAP : 30000 fsLF : NaN highPassFilterHz : 300 apGain : 500 apRange : [ - 0.6000 0.6000 ] lfGain : 250 lfRange : [ - 0.6000 0.6000 ] adcBits : 10 channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] syncChannelIndex : 385 syncInAPFile : 1 badChannels : [ 3 \u00d7 1 double ] syncBitNames : [ 16 \u00d7 1 string ] syncRaw : [] bytesPerSample : 2 hasAP : 0 hasLF : 0 channelMapFile : '~/npl/neuropixel-utils/map_files/neuropixPhase3A_kilosortChanMap.mat' mappedChannels : [ 384 \u00d7 1 double ] nChannelsMapped : 384 connectedChannels : [ 374 \u00d7 1 double ] nChannelsConnected : 374 goodChannels : [ 371 \u00d7 1 double ] nGoodChannels : 371 channelIdx : [ 384 \u00d7 1 double ] channelNames : [ 385 \u00d7 1 string ] channelNamesPadded : [ 385 \u00d7 1 string ] nSyncBits : 16 syncBitsNamed : [ 0 \u00d7 1 double ] creationTimeStr : '08-Jun-2018 12:09:07' apScaleToUv : 2.3438 lfScaleToUv : 2.3438 % Mark individual channels as bad based on RMS voltage >> rmsBadChannels = imec . markBadChannelsByRMS ( 'rmsRange' , [ 3 100 ]); % Specify names for the individual bits in the sync channel >> imec . setSyncBitNames ([ 1 2 3 ], { 'trialInfo' , 'trialStart' , 'stim' }); % Save the bad channels and Sync bit names to the .imec.ap.meta file so they are loaded next time >> imec . writeModifiedAPMeta (); % Perform common average referencing on the file and save the results to a new location >> cleanedPath = '/data/cleaned_datasets/neuropixel_01.imec.ap.bin' ; >> extraMeta = struct (); >> extraMeta . commonAverageReferenced = true ; >> fnList = {@ npxutils . dataprocess . commonAverageReference }; >> imec = imec . saveTransformedDataset ( cleanedPath , 'transformAP' , fnList , 'extraMeta' , extraMeta ); % Sym link the cleaned dataset into a separate directory for Kilosort2 >> ksPath = '/data/kilosort/neuropixel_01.imec.ap.bin' ; >> imec = imec . symLinkAPIntoDirectory ( ksPath ); % Inspect the raw IMEC traces >> imec . inspectAP_timeWindow ([ 200 201 ]); % 200-201 seconds into the recording Zoomed in view of data inspection figure. Black are good channels, blue are reference channels. Channels marked bad would be shown in red. % Run Kilosort2 >> npxutils . runKilosort2 ( imec ); % Load the Kilosort2 results >> ks = npxutils . KilosortDataset (); >> ks . load () KilosortDataset with properties: path : '/data/kilosort/neuropixel_01' raw_dataset : [ 1 \u00d7 1 npxutils . ImecDataset ] channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] fsAP : 30000 apScaleToUv : 2.3438 meta : [ 1 \u00d7 1 struct ] pathLeaf : 'neuropixel_01' isLoaded : 1 hasRawDataset : 1 nSpikes : 8181228 nChannelsSorted : 371 nClusters : 592 nTemplates : 653 nPCFeatures : 32 nFeaturesPerChannel : 3 nChannels : 371 syncBitNames : [ 16 \u00d7 1 string ] dat_path : 'neuropixel_01.imec.ap.bin' n_channels_dat : 385 dtype : 'int16' offset : 0 sample_rate : 30000 hp_filtered : 0 amplitudes : [ 8181228 \u00d7 1 double ] channel_ids : [ 371 \u00d7 1 uint32 ] channel_positions : [ 371 \u00d7 2 double ] pc_features : [ 8181228 \u00d7 3 \u00d7 32 single ] pc_feature_ind : [ 653 \u00d7 32 uint32 ] similar_templates : [ 653 \u00d7 653 single ] spike_templates : [ 8181228 \u00d7 1 uint32 ] spike_times : [ 8181228 \u00d7 1 uint64 ] template_features : [ 8181228 \u00d7 32 single ] template_feature_ind : [ 653 \u00d7 32 uint32 ] templates : [ 653 \u00d7 82 \u00d7 371 single ] templates_ind : [ 653 \u00d7 371 double ] whitening_mat : [ 371 \u00d7 371 double ] whitening_mat_inv : [ 371 \u00d7 371 double ] spike_clusters : [ 8181228 \u00d7 1 uint32 ] cluster_groups : [ 592 \u00d7 1 categorical ] cluster_ids : [ 592 \u00d7 1 uint32 ] clusters_good : [ 210 \u00d7 1 uint32 ] clusters_mua : [ 58 \u00d7 1 uint32 ] clusters_noise : [ 322 \u00d7 1 uint32 ] clusters_unsorted : [ 2 \u00d7 1 uint32 ] % Define how the data are segmented into trials (you implement this) >> tsi = computeTrialSegmentation ( imec ) TrialSegmentationInfo with properties : fs : 30000 trialId : [ 1072 \u00d7 1 uint32 ] conditionId : [ 1072 \u00d7 1 uint32 ] idxStart : [ 1072 \u00d7 1 uint64 ] idxStop : [ 1072 \u00d7 1 uint64 ] % Segment the KilosortDataset into trials based on start and stop idx % trial_ids are specified according to the data structure being merged into. % If a trial is included in trial_ids but not found in tsi, % its contents would be blank and trial_has_data(i) would be set false. % % Each of seg's properties are now nTrials x ... cells containing the data % corresponding to that trial >> trial_ids = min ( tsi . trialId ): max ( tsi . trialId ); >> seg = npxutils . KilosortTrialSegmentedDataset ( ks , tsi , trial_ids ) KilosortTrialSegmentedDataset with properties: dataset : [ 1 \u00d7 1 npxutils . KilosortDataset ] trial_ids : [ 1072 \u00d7 1 uint32 ] trial_has_data : [ 1072 \u00d7 1 logical ] trial_start : [ 1072 \u00d7 1 uint64 ] trial_stop : [ 1072 \u00d7 1 uint64 ] spike_idx : { 1072 \u00d7 592 cell } cluster_ids : [ 592 \u00d7 1 uint32 ] cluster_groups : [ 592 \u00d7 1 categorical ] sync : { 1072 \u00d7 1 cell } syncBitNames : [ 16 \u00d7 1 string ] raw_dataset : [ 1 \u00d7 1 npxutils . ImecDataset ] nTrials : 1072 nTrialsHaveData : 1072 nClusters : 592 nChannels : 385 trial_duration_ms : [ 1072 \u00d7 1 double ] fsAP : 30000 amplitudes : { 1072 \u00d7 592 cell } pc_features : { 1072 \u00d7 592 cell } spike_times : { 1072 \u00d7 592 cell } spike_times_ms_rel_start : { 1072 \u00d7 592 cell } template_features : { 1072 \u00d7 592 cell } spike_templates : { 1072 \u00d7 592 cell } % Compute useful stats about each template and cluster >> metrics = ks . getMetrics () KilosortMetrics with properties: ks : [ 1 \u00d7 1 npxutils . KilosortDataset ] fs : 30000 channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] channel_ids : [ 371 \u00d7 1 uint32 ] concatenatedStarts : 1 concatenatedNames : { 'neuropixel_01' } template_unw : [ 653 \u00d7 82 \u00d7 371 single ] template_scaled : [ 653 \u00d7 82 \u00d7 371 single ] template_centerOfMass : [ 653 \u00d7 2 single ] template_is_localized : [ 653 \u00d7 1 logical ] template_waveform : [ 653 \u00d7 82 single ] template_waveform_ch : [ 653 \u00d7 1 uint32 ] template_amplitude : [ 653 \u00d7 1 single ] template_ttp : [ 653 \u00d7 1 single ] template_best_channels : [ 653 \u00d7 371 uint32 ] spike_times : [ 8181228 \u00d7 1 uint64 ] spike_amplitude : [ 8181228 \u00d7 1 single ] spike_centerOfMass : [ 8181228 \u00d7 2 single ] spike_templates : [ 8181228 \u00d7 1 uint32 ] spike_clusters : [ 8181228 \u00d7 1 uint32 ] cluster_ids : [ 592 \u00d7 1 uint32 ] cluster_template_mostUsed : [ 592 \u00d7 1 uint32 ] cluster_template_list : { 592 \u00d7 1 cell } cluster_template_useCount : [ 592 \u00d7 653 uint64 ] cluster_num_templates : [ 592 \u00d7 1 uint32 ] cluster_best_channels : [ 592 \u00d7 371 uint32 ] cluster_centerOfMass : [ 592 \u00d7 2 single ] cluster_is_localized : [ 592 \u00d7 1 logical ] cluster_waveform : [ 592 \u00d7 82 \u00d7 11 single ] cluster_waveform_ch : [ 592 \u00d7 592 uint32 ] cluster_amplitude : [ 592 \u00d7 1 single ] cluster_ttp : [ 592 \u00d7 1 single ] spike_depth : [ 8181228 \u00d7 1 single ] spike_is_localized : [ 8181228 \u00d7 1 logical ] cluster_depth : [ 592 \u00d7 1 single ] % Plot a drift map, annotated with trial start markers >> metrics . plotDriftmap ( 'tsi' , tsi ); Note that the cluster structure looks distinct during a few time windows near the beginning and end of the recording, corresponding to regions when no trials were being performed (blue ticks near the bottom). % Extract raw waveforms for a specific cluster id at the 24 largest amplitude channels % Clean these waveforms by subtracting the contribution of other clusters spiking within the same time window >> ss = ks . getWaveformsFromRawData ( 'cluster_id' , 255 , 'num_waveforms' , 100 , 'best_n_channels' , 24 , 'subtractOtherClusters' , true ) SnippetSet with properties: data : [ 24 \u00d7 82 \u00d7 100 int16 ] cluster_idx : [ 100 \u00d7 1 uint32 ] channel_idx_by_cluster : [ 24 \u00d7 1 uint32 ] unique_cluster_idx : 255 sample_idx : [ 100 \u00d7 1 uint64 ] trial_idx : [ 0 \u00d7 1 uint32 ] window : [ - 40 41 ] valid : [ 100 \u00d7 1 logical ] channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] scaleToUv : 2.3438 fs : 30000 nChannels : 24 nTimepoints : 82 nSnippets : 100 nClusters : 1 data_valid : [ 24 \u00d7 82 \u00d7 100 int16 ] time_ms : [ 1 \u00d7 82 double ] % Plot these waveforms at their physical coordinates on the neuropixel >> ss . plotAtProbeLocations ()","title":"Overview"},{"location":"index.html#matlab-neuropixel-utilites","text":"Neuropixel Utils is a toolkit written in Matlab for manipulating datasets collected by SpikeGLX (e.g. imec.ap.bin files) and the results produced by Kilosort / Kilosort 2 . Please note that some of this functionality is redundant with the tools found in the Cortex Lab\u2019s spikes repository , authored By Nick Steinmetz, Mush Okun, and others. Here, we prioritize an organized, easy to use, object-oriented approach to accessing, manipulating, and visualizing the data. This reduces the need to worry about metadata. Neuropixel Utils facilitates the following data processing steps: Load and visualize raw neuropixel data from imec.ap.bin and imec.lf.bin files in Matlab. Write custom pre-processing functions to apply to raw data either by writing a copy of the raw file or modifying it in place, optionally removing specific problematic time windows in the file. Concatenate multiple Imec data files together while matching the amplifier gains. Run Kilosort/Kilosort2 , and load the results back into Matlab after manual inspection in Phy. Plot drift maps using code adapted from the spikes repository . Extract waveforms for each cluster from the raw data, optionally cleaning the snippets by subtracting templates for other clusters spiking during the same time window. Visualize cluster electrical spiking images in space and cluster locations on the probe . Determine trial boundaries in the file, and efficiently segment Kilosort results into individual trials . Neuropixel Utils was authored by Daniel J O\u2019Shea ( @djoshea ) to facilitate precision artifact removal and careful inspection of raw data traces before running Kilosort, as well as post-hoc verification that the artifacts were removed successfully.","title":"MATLAB Neuropixel Utilites"},{"location":"index.html#download-and-install","text":"To get started, clone the repo: git clone https://github.com/djoshea/neuropixel-utils.git And add it to your path in Matlab: >> addpath ( '/path/to/neuropixel-utils' )","title":"Download and install"},{"location":"index.html#example-walkthrough","text":"% Create an ImecDataset pointing at a specific >> channelMapFile = 'neuropixPhase3A_kilosortChanMap.mat' ; >> imec = npxutils . ImecDataset ( '/data/raw_datasets/neuropixel_01.imec.ap.bin' , 'channelMap' , channelMapFile ); ImecDataset with properties: pathRoot : '/data/raw_datasets' fileStem : 'neuropixel_01' creationTime : 7.3722e+05 nChannels : 385 fileTypeAP : 'ap' nSamplesAP : 112412208 nSamplesLF : 0 fsAP : 30000 fsLF : NaN highPassFilterHz : 300 apGain : 500 apRange : [ - 0.6000 0.6000 ] lfGain : 250 lfRange : [ - 0.6000 0.6000 ] adcBits : 10 channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] syncChannelIndex : 385 syncInAPFile : 1 badChannels : [ 3 \u00d7 1 double ] syncBitNames : [ 16 \u00d7 1 string ] syncRaw : [] bytesPerSample : 2 hasAP : 0 hasLF : 0 channelMapFile : '~/npl/neuropixel-utils/map_files/neuropixPhase3A_kilosortChanMap.mat' mappedChannels : [ 384 \u00d7 1 double ] nChannelsMapped : 384 connectedChannels : [ 374 \u00d7 1 double ] nChannelsConnected : 374 goodChannels : [ 371 \u00d7 1 double ] nGoodChannels : 371 channelIdx : [ 384 \u00d7 1 double ] channelNames : [ 385 \u00d7 1 string ] channelNamesPadded : [ 385 \u00d7 1 string ] nSyncBits : 16 syncBitsNamed : [ 0 \u00d7 1 double ] creationTimeStr : '08-Jun-2018 12:09:07' apScaleToUv : 2.3438 lfScaleToUv : 2.3438 % Mark individual channels as bad based on RMS voltage >> rmsBadChannels = imec . markBadChannelsByRMS ( 'rmsRange' , [ 3 100 ]); % Specify names for the individual bits in the sync channel >> imec . setSyncBitNames ([ 1 2 3 ], { 'trialInfo' , 'trialStart' , 'stim' }); % Save the bad channels and Sync bit names to the .imec.ap.meta file so they are loaded next time >> imec . writeModifiedAPMeta (); % Perform common average referencing on the file and save the results to a new location >> cleanedPath = '/data/cleaned_datasets/neuropixel_01.imec.ap.bin' ; >> extraMeta = struct (); >> extraMeta . commonAverageReferenced = true ; >> fnList = {@ npxutils . dataprocess . commonAverageReference }; >> imec = imec . saveTransformedDataset ( cleanedPath , 'transformAP' , fnList , 'extraMeta' , extraMeta ); % Sym link the cleaned dataset into a separate directory for Kilosort2 >> ksPath = '/data/kilosort/neuropixel_01.imec.ap.bin' ; >> imec = imec . symLinkAPIntoDirectory ( ksPath ); % Inspect the raw IMEC traces >> imec . inspectAP_timeWindow ([ 200 201 ]); % 200-201 seconds into the recording Zoomed in view of data inspection figure. Black are good channels, blue are reference channels. Channels marked bad would be shown in red. % Run Kilosort2 >> npxutils . runKilosort2 ( imec ); % Load the Kilosort2 results >> ks = npxutils . KilosortDataset (); >> ks . load () KilosortDataset with properties: path : '/data/kilosort/neuropixel_01' raw_dataset : [ 1 \u00d7 1 npxutils . ImecDataset ] channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] fsAP : 30000 apScaleToUv : 2.3438 meta : [ 1 \u00d7 1 struct ] pathLeaf : 'neuropixel_01' isLoaded : 1 hasRawDataset : 1 nSpikes : 8181228 nChannelsSorted : 371 nClusters : 592 nTemplates : 653 nPCFeatures : 32 nFeaturesPerChannel : 3 nChannels : 371 syncBitNames : [ 16 \u00d7 1 string ] dat_path : 'neuropixel_01.imec.ap.bin' n_channels_dat : 385 dtype : 'int16' offset : 0 sample_rate : 30000 hp_filtered : 0 amplitudes : [ 8181228 \u00d7 1 double ] channel_ids : [ 371 \u00d7 1 uint32 ] channel_positions : [ 371 \u00d7 2 double ] pc_features : [ 8181228 \u00d7 3 \u00d7 32 single ] pc_feature_ind : [ 653 \u00d7 32 uint32 ] similar_templates : [ 653 \u00d7 653 single ] spike_templates : [ 8181228 \u00d7 1 uint32 ] spike_times : [ 8181228 \u00d7 1 uint64 ] template_features : [ 8181228 \u00d7 32 single ] template_feature_ind : [ 653 \u00d7 32 uint32 ] templates : [ 653 \u00d7 82 \u00d7 371 single ] templates_ind : [ 653 \u00d7 371 double ] whitening_mat : [ 371 \u00d7 371 double ] whitening_mat_inv : [ 371 \u00d7 371 double ] spike_clusters : [ 8181228 \u00d7 1 uint32 ] cluster_groups : [ 592 \u00d7 1 categorical ] cluster_ids : [ 592 \u00d7 1 uint32 ] clusters_good : [ 210 \u00d7 1 uint32 ] clusters_mua : [ 58 \u00d7 1 uint32 ] clusters_noise : [ 322 \u00d7 1 uint32 ] clusters_unsorted : [ 2 \u00d7 1 uint32 ] % Define how the data are segmented into trials (you implement this) >> tsi = computeTrialSegmentation ( imec ) TrialSegmentationInfo with properties : fs : 30000 trialId : [ 1072 \u00d7 1 uint32 ] conditionId : [ 1072 \u00d7 1 uint32 ] idxStart : [ 1072 \u00d7 1 uint64 ] idxStop : [ 1072 \u00d7 1 uint64 ] % Segment the KilosortDataset into trials based on start and stop idx % trial_ids are specified according to the data structure being merged into. % If a trial is included in trial_ids but not found in tsi, % its contents would be blank and trial_has_data(i) would be set false. % % Each of seg's properties are now nTrials x ... cells containing the data % corresponding to that trial >> trial_ids = min ( tsi . trialId ): max ( tsi . trialId ); >> seg = npxutils . KilosortTrialSegmentedDataset ( ks , tsi , trial_ids ) KilosortTrialSegmentedDataset with properties: dataset : [ 1 \u00d7 1 npxutils . KilosortDataset ] trial_ids : [ 1072 \u00d7 1 uint32 ] trial_has_data : [ 1072 \u00d7 1 logical ] trial_start : [ 1072 \u00d7 1 uint64 ] trial_stop : [ 1072 \u00d7 1 uint64 ] spike_idx : { 1072 \u00d7 592 cell } cluster_ids : [ 592 \u00d7 1 uint32 ] cluster_groups : [ 592 \u00d7 1 categorical ] sync : { 1072 \u00d7 1 cell } syncBitNames : [ 16 \u00d7 1 string ] raw_dataset : [ 1 \u00d7 1 npxutils . ImecDataset ] nTrials : 1072 nTrialsHaveData : 1072 nClusters : 592 nChannels : 385 trial_duration_ms : [ 1072 \u00d7 1 double ] fsAP : 30000 amplitudes : { 1072 \u00d7 592 cell } pc_features : { 1072 \u00d7 592 cell } spike_times : { 1072 \u00d7 592 cell } spike_times_ms_rel_start : { 1072 \u00d7 592 cell } template_features : { 1072 \u00d7 592 cell } spike_templates : { 1072 \u00d7 592 cell } % Compute useful stats about each template and cluster >> metrics = ks . getMetrics () KilosortMetrics with properties: ks : [ 1 \u00d7 1 npxutils . KilosortDataset ] fs : 30000 channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] channel_ids : [ 371 \u00d7 1 uint32 ] concatenatedStarts : 1 concatenatedNames : { 'neuropixel_01' } template_unw : [ 653 \u00d7 82 \u00d7 371 single ] template_scaled : [ 653 \u00d7 82 \u00d7 371 single ] template_centerOfMass : [ 653 \u00d7 2 single ] template_is_localized : [ 653 \u00d7 1 logical ] template_waveform : [ 653 \u00d7 82 single ] template_waveform_ch : [ 653 \u00d7 1 uint32 ] template_amplitude : [ 653 \u00d7 1 single ] template_ttp : [ 653 \u00d7 1 single ] template_best_channels : [ 653 \u00d7 371 uint32 ] spike_times : [ 8181228 \u00d7 1 uint64 ] spike_amplitude : [ 8181228 \u00d7 1 single ] spike_centerOfMass : [ 8181228 \u00d7 2 single ] spike_templates : [ 8181228 \u00d7 1 uint32 ] spike_clusters : [ 8181228 \u00d7 1 uint32 ] cluster_ids : [ 592 \u00d7 1 uint32 ] cluster_template_mostUsed : [ 592 \u00d7 1 uint32 ] cluster_template_list : { 592 \u00d7 1 cell } cluster_template_useCount : [ 592 \u00d7 653 uint64 ] cluster_num_templates : [ 592 \u00d7 1 uint32 ] cluster_best_channels : [ 592 \u00d7 371 uint32 ] cluster_centerOfMass : [ 592 \u00d7 2 single ] cluster_is_localized : [ 592 \u00d7 1 logical ] cluster_waveform : [ 592 \u00d7 82 \u00d7 11 single ] cluster_waveform_ch : [ 592 \u00d7 592 uint32 ] cluster_amplitude : [ 592 \u00d7 1 single ] cluster_ttp : [ 592 \u00d7 1 single ] spike_depth : [ 8181228 \u00d7 1 single ] spike_is_localized : [ 8181228 \u00d7 1 logical ] cluster_depth : [ 592 \u00d7 1 single ] % Plot a drift map, annotated with trial start markers >> metrics . plotDriftmap ( 'tsi' , tsi ); Note that the cluster structure looks distinct during a few time windows near the beginning and end of the recording, corresponding to regions when no trials were being performed (blue ticks near the bottom). % Extract raw waveforms for a specific cluster id at the 24 largest amplitude channels % Clean these waveforms by subtracting the contribution of other clusters spiking within the same time window >> ss = ks . getWaveformsFromRawData ( 'cluster_id' , 255 , 'num_waveforms' , 100 , 'best_n_channels' , 24 , 'subtractOtherClusters' , true ) SnippetSet with properties: data : [ 24 \u00d7 82 \u00d7 100 int16 ] cluster_idx : [ 100 \u00d7 1 uint32 ] channel_idx_by_cluster : [ 24 \u00d7 1 uint32 ] unique_cluster_idx : 255 sample_idx : [ 100 \u00d7 1 uint64 ] trial_idx : [ 0 \u00d7 1 uint32 ] window : [ - 40 41 ] valid : [ 100 \u00d7 1 logical ] channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] scaleToUv : 2.3438 fs : 30000 nChannels : 24 nTimepoints : 82 nSnippets : 100 nClusters : 1 data_valid : [ 24 \u00d7 82 \u00d7 100 int16 ] time_ms : [ 1 \u00d7 82 double ] % Plot these waveforms at their physical coordinates on the neuropixel >> ss . plotAtProbeLocations ()","title":"Example walkthrough"},{"location":"acknowledgements.html","text":"Acknowledgements \u00b6 Neuropixels and Kilosort \u00b6 Many of the core ideas and data structures used in these utilities are reorganized versions of existing code, and I am very grateful for the authors who have written, documented, and released their code open source to the community. These sources include: Harris+Carandini Cortex Lab spikes repo Harris+Carandini Cortex Lab neuropixels wiki Kilosort Kilosort2 Phy and phy-contrib In particular, I\u2019d like to acknowledge Nick Steinmetz and Marius Pachitariu for Neuropixel and Kilosort related resources they\u2019ve provided to the community. Packaged external dependencies \u00b6 I\u2019d also like to acknowledge several authors whose Matlab File Exchange contributions are included within neuropixel-utils. Because Matlab doesn\u2019t have any useful dependency management system, I find it easier to simply include these contributions directly rather than asking users to download multiple dependencies by hand. These files are licensed as described in the files. Timothy E. Holy : distinguishable_colors Jan Simon : GetFullPath Suresh E. Joel : hsl2rgb and rgb2hsl Jochen Lenz: relativepath Chad A. Greene: cmocean , based on Kristen M. Thyng, Chad A. Greene, Robert D. Hetland, Heather M. Zimmerle, and Steven F. DiMarco. True colors of oceanography: Guidelines for effective and accurate colormap selection. Oceanography , September 2016. Matlab coding \u00b6 Neuropixel Utils\u2019 repo organization and packaging system is based on Janklab\u2019s MatlabProjectTemplate structure, adapted with financial support from MathWorks. Support \u00b6 If you have any issues using this code with your data, please look for any similar existing GitHub issues or file a new issue there. Please don\u2019t email me straight away unless there\u2019s some need for confidentiality, as I\u2019ll most likely ask you to file a GitHub issue anyway. Across multiple repositiories, this policy helps me keep track of what needs to be fixed, and also helps other users who may have been encountering similar issues. Thanks!","title":"Acknowledgements and Support"},{"location":"acknowledgements.html#acknowledgements","text":"","title":"Acknowledgements"},{"location":"acknowledgements.html#neuropixels-and-kilosort","text":"Many of the core ideas and data structures used in these utilities are reorganized versions of existing code, and I am very grateful for the authors who have written, documented, and released their code open source to the community. These sources include: Harris+Carandini Cortex Lab spikes repo Harris+Carandini Cortex Lab neuropixels wiki Kilosort Kilosort2 Phy and phy-contrib In particular, I\u2019d like to acknowledge Nick Steinmetz and Marius Pachitariu for Neuropixel and Kilosort related resources they\u2019ve provided to the community.","title":"Neuropixels and Kilosort"},{"location":"acknowledgements.html#packaged-external-dependencies","text":"I\u2019d also like to acknowledge several authors whose Matlab File Exchange contributions are included within neuropixel-utils. Because Matlab doesn\u2019t have any useful dependency management system, I find it easier to simply include these contributions directly rather than asking users to download multiple dependencies by hand. These files are licensed as described in the files. Timothy E. Holy : distinguishable_colors Jan Simon : GetFullPath Suresh E. Joel : hsl2rgb and rgb2hsl Jochen Lenz: relativepath Chad A. Greene: cmocean , based on Kristen M. Thyng, Chad A. Greene, Robert D. Hetland, Heather M. Zimmerle, and Steven F. DiMarco. True colors of oceanography: Guidelines for effective and accurate colormap selection. Oceanography , September 2016.","title":"Packaged external dependencies"},{"location":"acknowledgements.html#matlab-coding","text":"Neuropixel Utils\u2019 repo organization and packaging system is based on Janklab\u2019s MatlabProjectTemplate structure, adapted with financial support from MathWorks.","title":"Matlab coding"},{"location":"acknowledgements.html#support","text":"If you have any issues using this code with your data, please look for any similar existing GitHub issues or file a new issue there. Please don\u2019t email me straight away unless there\u2019s some need for confidentiality, as I\u2019ll most likely ask you to file a GitHub issue anyway. Across multiple repositiories, this policy helps me keep track of what needs to be fixed, and also helps other users who may have been encountering similar issues. Thanks!","title":"Support"},{"location":"analysis.html","text":"Analysis of Kilosort Results \u00b6 Simple statistics \u00b6 Simple statistics for a KilosortDataset can be computed / printed using: >> stats = ks . computeBasicStats (); >> ks . printBasicStats (); neuropixel_01 : 3747.1 sec , 8181228 ( 6974070 ) spikes , 592 ( 187 ) clusters ( with fr > 3 Hz ) >> stats stats = struct with fields : spike_clusters : [ 8181228 \u00d7 1 uint32 ] cluster_ids : [ 592 \u00d7 1 uint32 ] offset : 0 sample_rate : 30000 spike_times : [ 8181228 \u00d7 1 uint64 ] nSpikes : 8181228 nClusters : 592 nSec : 3.7471e+03 fr : [ 1 \u00d7 591 double ] thresh : 3 clusterMask : [ 1 \u00d7 591 logical ] nClustersAboveThresh : 187 nSpikesAboveThresh : 6974070 KilosortMetrics \u00b6 More computed statistics can be computed on demand by calling: metrics = ks . computeMetrics (); which returns a npxutils.KilosortMetrics instance. This is a catch-all class for storing all the statistics we want to compute about the results of a Kilosort run. At the moment, most of these properties are related to localizing spikes / templates / clusters in spatial coordinates on the probe. The details of these computations borrow heavily from code written by Nick Steinmetz described on the Neuropixels wiki . Many properties are computed for each cluster, for each template (as multiple templates may comprise each cluster), and for each individual spike. Spatial location properties end in _centerOfMass , and have x,y (and someday z) along the second dimension. depth properties are shorthands for the y spatial dimension of centerOfMass . waveform properties store the template-derived waveform taken from the largest channel. best_channels properties indicate which channels best capture the electrical image of a given template or cluster. * amplitude properties are already in uV. is_localized properties indicate whether the electrical image is sufficiently well localized in space. KilosortMetrics with properties: ks: [1\u00d71 npxutils.KilosortDataset] nSpikes: 8181228 nChannelsSorted: 371 nTemplates: 653 nTemplateTimepoints: 82 nClusters: 592 nConcatenatedFiles: 1 maxTemplatesPerCluster: 11 fs: 30000 channelMap: [1\u00d71 npxutils.ChannelMap] channel_ids: [nChannelsSorted \u00d7 1 uint32] concatenatedSamples: 112412208 concatenatedStarts: 1 concatenatedNames: \"neuropixel_01\" template_unw: [nTemplates \u00d7 nTemplateTimepoints \u00d7 nChannelsSorted single] % unwhitened templates in original data scale template_scaled: [nTemplates \u00d7 nTemplateTimepoints \u00d7 nChannelsSorted single] % unwhitened, scaled templates in uV template_centerOfMass: [nTemplates \u00d7 2 single] template_is_localized: [nTemplates \u00d7 1 logical] template_waveform: [nTemplates \u00d7 nTemplateTimepoints single] template_waveform_ch: [nTemplates \u00d7 1 uint32] template_amplitude: [nTemplates \u00d7 1 single] template_ttp: [nTemplates \u00d7 1 single] template_best_channels: [nTemplates \u00d7 nChannelsSorted uint32] spike_times: [nSpikes \u00d7 1 uint64] spike_amplitude: [nSpikes \u00d7 1 single] spike_centerOfMass: [nSpikes \u00d7 2 single] % x, y spike_templates: [nSpikes \u00d7 1 uint32] spike_clusters: [nSpikes \u00d7 1 uint32] spike_depth: [nSpikes \u00d7 1 single] spike_is_localized: [nSpikes \u00d7 1 logical] cluster_ids: [nClusters \u00d7 1 uint32] cluster_template_mostUsed: [nClusters \u00d7 1 uint32] cluster_template_list: {nClusters \u00d7 1 cell} cluster_template_useCount: [nClusters \u00d7 nTemplates uint64] cluster_num_templates: [nClusters \u00d7 1 uint32] cluster_best_channels: [nClusters \u00d7 nChannelsSorted uint32] cluster_centerOfMass: [nClusters \u00d7 2 single] % x, y cluster_is_localized: [nClusters \u00d7 1 logical] cluster_waveform: [nClusters \u00d7 nTemplateTimepoints \u00d7 maxTemplatesPerCluster single] cluster_waveform_ch: [nClusters \u00d7 nClusters uint32] cluster_amplitude: [nClusters \u00d7 1 single] cluster_ttp: [nClusters \u00d7 1 single] cluster_depth: [nClusters \u00d7 1 single] Plotting drift maps \u00b6 A drift map plots the spatial depth of all spikes over time as individual dots, where the dot color darkness increases for large amplitude spikes, allowing the eye to follow bands of spikes over time. The code for generating this plot was largely copied from the Cortex lab spikes repo and modified to use the KilosortMetrics structure and add some additional metadata. You can plot a standard driftmap using: metrics . plotDriftmap (); Significant drift events are marked in red in the raster and shown as red ticks above. You can set the driftThreshold in \u00b5m for drift events as a parameter, as well as lower the threshold for spike amplitude quantile to include smaller spikes in the calculation: metrics . plotDriftmap ( 'driftThreshold' , 4 , 'spikeAmpQuantile' , 0.8 ); If you have computed trial segmentation boundaries stored in a TrialSegmentationInfo instance, you can pass them in to show the trial boundaries as blue ticks at the bottom. metrics . plotDriftmap ( 'tsi' , tsi ); As you can see, the vertical bands where spiking activity look very different from other timepoints occur when no trials were present. Indeed, these were time periods where the task was paused and the subject was asleep. We can mask out these regions to better assess drift over the time periods we\u2019re most concerned with: metrics . plotDriftmap ( 'tsi' , tsi , 'maskRegionsOutsideTrials' , true ); Or we can excise those regions of time for plotting purposes only, to simulate what would happen if we excised those regions during pre-processing . Locations where timepoints are spliced together are indicated using magenta lines. metrics . plotDriftmap ( 'tsi' , tsi , 'exciseRegionsOutsideTrials' , true ); Plotting cluster drift maps \u00b6 The driftmaps can help the eye spot points where spikes shift in space, but they do not indicate where Kilosort may have split a cluster over time. metrics.plotClusterDriftmap is similar to plotDriftmap except that it colors each dot according to cluster id. For these plots, it is helpful to subselect a subset of cluster ids to keep the plots from being too dense. Cluster ids tend to be roughly in order along the probe because of Kilosort\u2019s algorithm, so be sure to sample uniformly over the cluster ids when subselecting. cluster_ids = metrics . cluster_ids ( 1 : 5 : metrics . nClusters ); metrics . plotDriftmap ( 'tsi' , tsi , 'exciseRegionsOutsideTrials' , true , 'cluster_ids' , cluster_ids ); Hover over tool tips For these plots, in newer versions of Matlab, you can hover over points in the plot to see a popup tooltip that will display information about the cluster to which that point belongs. You can also tweak the colors of each cluster so that larger amplitude clusters appear brighter using 'colorByAmp', true . metrics . plotDriftmap ( 'tsi' , tsi , 'exciseRegionsOutsideTrials' , true , 'cluster_ids' , cluster_ids , 'colorByAmp' , true ); By default, larger clusters are plotted on top, but you can randomize the plotting order using 'zShuffleClusters', true . Instead of plotting each individual spike, you can plot a smoothed estimate of cluster depth by passing 'showSmooth', true, 'showIndividual', false : metrics . plotDriftmap ( 'tsi' , tsi , 'exciseRegionsOutsideTrials' , true , 'cluster_ids' , cluster_ids , ... 'showSmooth' , true , 'showIndividual' , false , 'smoothWidthSeconds' , 50 ); Plotting cluster centers of mass \u00b6 To see the distribution of cluster waveforms over the probe: metrics . plotClusterWaveformAtCentroid () Hover over tool tips For these plots, in newer versions of Matlab, you can hover over waveforms in the plot to see a popup tooltip that will display information about the cluster to which that waveform belongs. Plotting electrical images \u00b6 You can plot the electrical image of each cluster\u2019s templates (or an individual template) as well, using ymag and xmag to zoom in after normalizing. cluster_id = 10 ; metrics . plotClusterImage ( cluster_id , 'ymag' , 10 , 'xmag' , 2 ) Rather than plotting every channel, you can select the best N contiguous channels: metrics . plotClusterImage ( cluster_id , 'best_n_channels' , 20 );","title":"Analysis of Kilosort Results"},{"location":"analysis.html#analysis-of-kilosort-results","text":"","title":"Analysis of Kilosort Results"},{"location":"analysis.html#simple-statistics","text":"Simple statistics for a KilosortDataset can be computed / printed using: >> stats = ks . computeBasicStats (); >> ks . printBasicStats (); neuropixel_01 : 3747.1 sec , 8181228 ( 6974070 ) spikes , 592 ( 187 ) clusters ( with fr > 3 Hz ) >> stats stats = struct with fields : spike_clusters : [ 8181228 \u00d7 1 uint32 ] cluster_ids : [ 592 \u00d7 1 uint32 ] offset : 0 sample_rate : 30000 spike_times : [ 8181228 \u00d7 1 uint64 ] nSpikes : 8181228 nClusters : 592 nSec : 3.7471e+03 fr : [ 1 \u00d7 591 double ] thresh : 3 clusterMask : [ 1 \u00d7 591 logical ] nClustersAboveThresh : 187 nSpikesAboveThresh : 6974070","title":"Simple statistics"},{"location":"analysis.html#kilosortmetrics","text":"More computed statistics can be computed on demand by calling: metrics = ks . computeMetrics (); which returns a npxutils.KilosortMetrics instance. This is a catch-all class for storing all the statistics we want to compute about the results of a Kilosort run. At the moment, most of these properties are related to localizing spikes / templates / clusters in spatial coordinates on the probe. The details of these computations borrow heavily from code written by Nick Steinmetz described on the Neuropixels wiki . Many properties are computed for each cluster, for each template (as multiple templates may comprise each cluster), and for each individual spike. Spatial location properties end in _centerOfMass , and have x,y (and someday z) along the second dimension. depth properties are shorthands for the y spatial dimension of centerOfMass . waveform properties store the template-derived waveform taken from the largest channel. best_channels properties indicate which channels best capture the electrical image of a given template or cluster. * amplitude properties are already in uV. is_localized properties indicate whether the electrical image is sufficiently well localized in space. KilosortMetrics with properties: ks: [1\u00d71 npxutils.KilosortDataset] nSpikes: 8181228 nChannelsSorted: 371 nTemplates: 653 nTemplateTimepoints: 82 nClusters: 592 nConcatenatedFiles: 1 maxTemplatesPerCluster: 11 fs: 30000 channelMap: [1\u00d71 npxutils.ChannelMap] channel_ids: [nChannelsSorted \u00d7 1 uint32] concatenatedSamples: 112412208 concatenatedStarts: 1 concatenatedNames: \"neuropixel_01\" template_unw: [nTemplates \u00d7 nTemplateTimepoints \u00d7 nChannelsSorted single] % unwhitened templates in original data scale template_scaled: [nTemplates \u00d7 nTemplateTimepoints \u00d7 nChannelsSorted single] % unwhitened, scaled templates in uV template_centerOfMass: [nTemplates \u00d7 2 single] template_is_localized: [nTemplates \u00d7 1 logical] template_waveform: [nTemplates \u00d7 nTemplateTimepoints single] template_waveform_ch: [nTemplates \u00d7 1 uint32] template_amplitude: [nTemplates \u00d7 1 single] template_ttp: [nTemplates \u00d7 1 single] template_best_channels: [nTemplates \u00d7 nChannelsSorted uint32] spike_times: [nSpikes \u00d7 1 uint64] spike_amplitude: [nSpikes \u00d7 1 single] spike_centerOfMass: [nSpikes \u00d7 2 single] % x, y spike_templates: [nSpikes \u00d7 1 uint32] spike_clusters: [nSpikes \u00d7 1 uint32] spike_depth: [nSpikes \u00d7 1 single] spike_is_localized: [nSpikes \u00d7 1 logical] cluster_ids: [nClusters \u00d7 1 uint32] cluster_template_mostUsed: [nClusters \u00d7 1 uint32] cluster_template_list: {nClusters \u00d7 1 cell} cluster_template_useCount: [nClusters \u00d7 nTemplates uint64] cluster_num_templates: [nClusters \u00d7 1 uint32] cluster_best_channels: [nClusters \u00d7 nChannelsSorted uint32] cluster_centerOfMass: [nClusters \u00d7 2 single] % x, y cluster_is_localized: [nClusters \u00d7 1 logical] cluster_waveform: [nClusters \u00d7 nTemplateTimepoints \u00d7 maxTemplatesPerCluster single] cluster_waveform_ch: [nClusters \u00d7 nClusters uint32] cluster_amplitude: [nClusters \u00d7 1 single] cluster_ttp: [nClusters \u00d7 1 single] cluster_depth: [nClusters \u00d7 1 single]","title":"KilosortMetrics"},{"location":"analysis.html#plotting-drift-maps","text":"A drift map plots the spatial depth of all spikes over time as individual dots, where the dot color darkness increases for large amplitude spikes, allowing the eye to follow bands of spikes over time. The code for generating this plot was largely copied from the Cortex lab spikes repo and modified to use the KilosortMetrics structure and add some additional metadata. You can plot a standard driftmap using: metrics . plotDriftmap (); Significant drift events are marked in red in the raster and shown as red ticks above. You can set the driftThreshold in \u00b5m for drift events as a parameter, as well as lower the threshold for spike amplitude quantile to include smaller spikes in the calculation: metrics . plotDriftmap ( 'driftThreshold' , 4 , 'spikeAmpQuantile' , 0.8 ); If you have computed trial segmentation boundaries stored in a TrialSegmentationInfo instance, you can pass them in to show the trial boundaries as blue ticks at the bottom. metrics . plotDriftmap ( 'tsi' , tsi ); As you can see, the vertical bands where spiking activity look very different from other timepoints occur when no trials were present. Indeed, these were time periods where the task was paused and the subject was asleep. We can mask out these regions to better assess drift over the time periods we\u2019re most concerned with: metrics . plotDriftmap ( 'tsi' , tsi , 'maskRegionsOutsideTrials' , true ); Or we can excise those regions of time for plotting purposes only, to simulate what would happen if we excised those regions during pre-processing . Locations where timepoints are spliced together are indicated using magenta lines. metrics . plotDriftmap ( 'tsi' , tsi , 'exciseRegionsOutsideTrials' , true );","title":"Plotting drift maps"},{"location":"analysis.html#plotting-cluster-drift-maps","text":"The driftmaps can help the eye spot points where spikes shift in space, but they do not indicate where Kilosort may have split a cluster over time. metrics.plotClusterDriftmap is similar to plotDriftmap except that it colors each dot according to cluster id. For these plots, it is helpful to subselect a subset of cluster ids to keep the plots from being too dense. Cluster ids tend to be roughly in order along the probe because of Kilosort\u2019s algorithm, so be sure to sample uniformly over the cluster ids when subselecting. cluster_ids = metrics . cluster_ids ( 1 : 5 : metrics . nClusters ); metrics . plotDriftmap ( 'tsi' , tsi , 'exciseRegionsOutsideTrials' , true , 'cluster_ids' , cluster_ids ); Hover over tool tips For these plots, in newer versions of Matlab, you can hover over points in the plot to see a popup tooltip that will display information about the cluster to which that point belongs. You can also tweak the colors of each cluster so that larger amplitude clusters appear brighter using 'colorByAmp', true . metrics . plotDriftmap ( 'tsi' , tsi , 'exciseRegionsOutsideTrials' , true , 'cluster_ids' , cluster_ids , 'colorByAmp' , true ); By default, larger clusters are plotted on top, but you can randomize the plotting order using 'zShuffleClusters', true . Instead of plotting each individual spike, you can plot a smoothed estimate of cluster depth by passing 'showSmooth', true, 'showIndividual', false : metrics . plotDriftmap ( 'tsi' , tsi , 'exciseRegionsOutsideTrials' , true , 'cluster_ids' , cluster_ids , ... 'showSmooth' , true , 'showIndividual' , false , 'smoothWidthSeconds' , 50 );","title":"Plotting cluster drift maps"},{"location":"analysis.html#plotting-cluster-centers-of-mass","text":"To see the distribution of cluster waveforms over the probe: metrics . plotClusterWaveformAtCentroid () Hover over tool tips For these plots, in newer versions of Matlab, you can hover over waveforms in the plot to see a popup tooltip that will display information about the cluster to which that waveform belongs.","title":"Plotting cluster centers of mass"},{"location":"analysis.html#plotting-electrical-images","text":"You can plot the electrical image of each cluster\u2019s templates (or an individual template) as well, using ymag and xmag to zoom in after normalizing. cluster_id = 10 ; metrics . plotClusterImage ( cluster_id , 'ymag' , 10 , 'xmag' , 2 ) Rather than plotting every channel, you can select the best N contiguous channels: metrics . plotClusterImage ( cluster_id , 'best_n_channels' , 20 );","title":"Plotting electrical images"},{"location":"imec_dataset.html","text":"npxutils.ImecDataset \u00b6 The npxutils.ImecDataset class wraps one individual recording session acquired with SpikeGLX. Currently, four files with extensions .imec.ap.bin , .imec.ap.meta , .imec.lf.bin , and .imec.lf.meta comprise one ImecDataset. Constructing a npxutils.ImecDataset \u00b6 You construct a npxutils.ImecDataset by pointing it at the path to your dataset. How you specify the path is flexible. You can point directly at one of the files: imec = npxutils . ImecDataset ( '/data/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin' ); Or specify the common prefix to the .imec.* files comprising the dataset: imec = npxutils . ImecDataset ( '/data/raw_datasets/neuropixel_01_g0_t0' ); The common prefix can be shorter as long as there is no ambiguity: imec = npxutils . ImecDataset ( '/data/raw_datasets/neuropixel_01' ); You can also point at the parent directory as long as only one .ap.bin file is contained within. imec = npxutils . ImecDataset ( '/data/raw_datasets/' ); These are all equivalent, in that the resulting imec instance will wrap both AP and LF bin and meta files. (Though it\u2019s okay if the LF files are missing). Specifying a Channel Map \u00b6 When constructing the ImecDataset, you can specify a channel map. If you don\u2019t specify one, the default will be returned by npxutils.util.getDefaultChannelMapFile() , which in turn will look for the file pointed to by the environment variables 'NEUROPIXEL_MAP_FILE' or 'NPIX_MAP_FILE' . You can set these using Matlab\u2019s setenv function. These .mat files are expected to be in the same format as found on the neuropixels repo . For the phase 3A probe with 384 channels, the file neuropixPhase3A_kilosortChanMap.mat contains: >> ld = load ( 'neuropixPhase3A_kilosortChanMap.mat' ) struct with fields : chanMap : [ 384 \u00d7 1 double ] chanMap0ind : [ 384 \u00d7 1 double ] connected : [ 384 \u00d7 1 logical ] shankInd : [ 384 \u00d7 1 double ] xcoords : [ 384 \u00d7 1 double ] ycoords : [ 384 \u00d7 1 double ] You can construct a ChannelMap directly by pointing at the .mat file, although every function within neuropixel-utils will also accept the filename and construct the ChannelMap for you: chanMap = npxutils . ChannelMap ( mat_file_path ); Then you can use this map for an ImecDataset using: imec = npxutils . ImecDataset ( 'channelMap' , chanMap ); imec = npxutils . ImecDataset ( 'channelMap' , mat_file_path ); Exploring metadata \u00b6 When the ImecDataset is created, the metadata are loaded from the .ap.meta file. You can request the full metadata using meta = imec . readAPMeta () struct with fields : acqApLfSy : [ 384 384 1 ] appVersion : 20171101 fileCreateTime : '2018-06-08T12:09:07' fileName : 'neuropixel_01_g0_t0.imec.ap.bin' fileSHA1 : '36E9F78B0725C15431E12DEC516A779A31643ED8' fileSizeBytes : 8.6557e+10 fileTimeSecs : 3.7471e+03 firstSample : 7060812 gateMode : 'Immediate' ... The most commonly accessed metadata is stored in properties of the ImecDataset: ImecDataset with properties: pathRoot : '/data/neuropixel/raw_datasets' % parent directories fileStem : 'neuropixel_01_g0_t0' % common prefix creationTime : 7.3722e+05 % datenum nChannels : 385 % total number of channels in the data file fileTypeAP : 'ap' % indicates the file suffix right before .bin, usually ap or ap_CAR nSamplesAP : 112412208 % number of time samples in the AP file nSamplesLF : 0 % number of time samples in the LF file (if present) fsAP : 30000 % sampling rate in Hz fsLF : NaN % sampling rate in Hz highPassFilterHz : 300 % online high pass filter pole (imHpFlt) apGain : 500 % AP gain selected apRange : [ - 0.6000 0.6000 ] % voltage range on ADC lfGain : 250 % LF gain selected lfRange : [ - 0.6000 0.6000 ] % voltage range on ADC adcBits : 10 % number of ADC bits used channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] % channel map for this recording syncChannelIndex : 385 % index of the sync channel if present in AP file syncInAPFile : 1 % whether the sync channels is present in the AP file badChannels : [ 3 \u00d7 1 double ] % list of channels marked as bad syncBitNames : [ 16 \u00d7 1 string ] % user-specified names of each sync bit for convenience syncRaw : [] % cached contents of sync if loaded bytesPerSample : 2 % currently fixed at 2 for int16 samples hasAP : 1 % was an associated AP file present? hasLF : 0 % was an associated LF file present? channelMapFile : '~/npl/neuropixel-utils/map_files/neuropixPhase3A_kilosortChanMap.mat' % full path to channel map file mappedChannels : [ 384 \u00d7 1 double ] % list of channel ids that have coordinates in the channel map nChannelsMapped : 384 connectedChannels : [ 374 \u00d7 1 double ] % list of channel ids that are connected to voltage pads nChannelsConnected : 374 goodChannels : [ 371 \u00d7 1 double ] % list of channel ids that are marked good (or not marked as bad) nGoodChannels : 371 channelIds : [ 384 \u00d7 1 double ] % list of channel ids present in the channel map channelNames : [ 385 \u00d7 1 string ] % autogenerated names for each channel channelNamesPadded : [ 385 \u00d7 1 string ] % autogenerated names for each channel, where numbers are padded with spaces nSyncBits : 16 syncBitsNamed : [ 8 \u00d7 1 double ] % which of the sync bits have user provided names fileAP : 'neuropixel_01_g0_t0.imec.ap.bin' pathAP : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin' fileAPMeta : 'neuropixel_01_g0_t0.imec.ap.meta' pathAPMeta : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.imec.ap.meta' fileLF : 'neuropixel_01_g0_t0.imec.lf.bin' pathLF : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.imec.lf.bin' fileLFMeta : 'neuropixel_01_g0_t0.imec.lf.meta' pathLFMeta : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.imec.lf.meta' fileSync : 'neuropixel_01_g0_t0.imec.ap.bin' pathSync : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin' fileSyncCached : 'neuropixel_01_g0_t0.sync.mat' % location where sync data will be cached for quick access pathSyncCached : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.sync.mat' creationTimeStr : '08-Jun-2018 12:09:07' apScaleToUv : 2.3438 % conversion factor. Multiply raw AP int16s by this to get uV lfScaleToUv : 2.3438 % conversion factor. Multiply raw LF int16s by this to get uV Setting sync bit names \u00b6 For convenience, if you use the sync bits for individual TTL signals during your recordings, you can set their names for the recording so that subsequent processing can refer to the bits by name rather than index. You may also find it useful to store additional data in some sync bits during subsequent processing, such as marking regions of time where an artifact was detected, such that specifying the bit by name is useful. Bits are ordered like bitget , i.e. 1 is the least significant bit. imec . setSyncBitNames ( 1 , \"trialStart\" ) The full set of sync bits is found in imec.syncBitNames , or you can lookup the bit corresponding to a given name using: idx = imec . lookupSyncBitByName ( \"trialStart\" ) Marking bad channels \u00b6 You can manually mark specific channels as bad using: imec . markBadChannels ( channelIds ); Use channel IDs, not indices Note that like all channel lists, channelIds is specified using the actual unique ids of each channel (as specified in the ChannelMap), which is not necessarily their index into the channel map if the channels are not contiguously numbered. You can use lookup_channelIds to find the channel indices for a given set of channel ids if needed: [ channelInds , channelIds ] = imec . lookup_channelIds ( channelIds ) One common task is marking channels as bad if their RMS voltage lies outside a reasonable range: imec . markBadChannelsByRMS ( 'rmsRange' , [ 3 100 ]); % [low high] range of RMS in uV The remaining \u201cgood\u201d channel ids can always be accessed using imec.goodChannels which will be the set of connected channels excluding the bad channels. Writing modified metadata back to disk \u00b6 After making any modifications to the metadata, such as setting the sync bit names or marking bad channels, you can write it back to disk (in the .imec.ap.meta file) such that it will be reloaded automatically the next time you create an ImecDataset instance for that file. imec . writeModifiedAPMeta (); You can also append whatever fields you want to the meta file using the extraMeta parameter: extraMeta . cleaned = true ; extraMeta . cleaningAlgorithm = 'v1' ; imec . writeModifiedAPMeta ( 'extraMeta' , extraMeta ); Accessing data \u00b6 Raw memory maps \u00b6 The most convenient way to access the data is to request a memory map: mmap = imec . memmapAP_full (); value = mmap . Data . x ( ch_index , sample_index ); % access a specific sample Equivalent functionality is available for LF files using imec.memmapLF_full() . If you wish to modify the underlying data file directly, you can also request a Writeable version of the memory map: mmap = imec . memmapAP_full ( 'Writable' , true ); mmap . Data . x ( ch_index , sample_index ) = new_value ; % overwrite a specific sample Reading specific time window \u00b6 You can also request a specific sample or time window directly: idxWindow = [ idxFirst idxLast ]; [ data_partial , sampleIdx ] = imec . readAP_idx ( idxWindow ); timeWindow = [ secStart , secStop ]; % in seconds [ data_partial , sampleIdx ] = imec . readAP_timeWindow ( timeWindow ); Plotting specific time windows \u00b6 You can also quickly generate a stacked traces plot of a specific time window, optionally selecting which channels to plot. Take care to select a reasonable time window to avoid overwhelming your system. All channels are individually centered and then collectively normalized by the maximum value before plotting. You can change the global scaling factor by specifying gain > 1. imec . inspectAP_idxWindow ( idxWindow , ... ) imec . inspectAP_timeWindow ( timeWindow , ... ) There are additional optional parameters you can specify: channels : channel indices to plot, defaults to imec.mappedChannels . syncBits : which sync bits to plot individually, defaults to imec.syncBitsNamed . gain : global scaling factor, values larger then 1 will magnify the individual channels, defaults to 0.95. car : perform common average referencing before plotting, defaults to false. downsample : take every nth sample to speed up plotting, defaults to 1. Good channels are plotted in black, non-connected channels in blue, and bad channels in red. Sync bits are also shown in red and are not affected by the normalization gain. Reading sync channel \u00b6 You can access the sync channel all at once using: sync = imec . readSync (); trialStartBit = imec . readSyncBit ( \"trialStart\" ); Or a specific sample or time window using: [ sync_partial , sampleIdx ] = imec . readSync_idx ( idxWindow ); [ sync_partial , sampleIdx ] = imec . readSync_timeWindow ( timeWindow ); You can also access the logical values of specific bits either by bit index or name using: partial = imec . readSyncBits_idx ( bits_or_names , idxWindow ); % nTime x nBits trialStart_partial = imec . readSyncBits_idx ( \"trialStart\" , idxWindow ); % nTime x 1 Building a preprocessing pipeline \u00b6 If the raw .imec.ap.bin file must be processed in some way before running Kilosort, e.g. to remove artifacts, you can implement this efficiently by writing a transformation function that will act on chunks of the data. One example is found in npxutils.dataprocess.commonAverageReference : function [data, extra] = commonAverageReference ( imec, data, chIds, sampleIdx ) %#ok<INUSD> % chIds are the channel ids and imec.goodChannels is a list of channel ids % so this will lookup the channel indices of those channels both in chIdx that % are also marked as good. This prevents us from computing the reference % from the sync, reference, or bad channels. chanMask = imec . lookup_channelIds ( intersect ( chIds , imec . goodChannels )); % subtract median of each channel over time data ( chanMask , :) = bsxfun (@ minus , data ( chanMask , :), median ( data ( chanMask , :), 2 )); % subtract median across good channels data ( chanMask , :) = bsxfun (@ minus , data ( chanMask , :), median ( data ( chanMask , :), 1 )); end Essentially, your transform function can perform any modifications to the data matrix and return the resulting data matrix. Here, imec will be the ImecDataset being transformed, data will be the nChannels x nTime chunk of data being processed. chIds will be the channel ids (not necessarily their indices into data but the ids assigned by the channel map), and will typically be the full list of channel ids present in the data file. sampleIdx is the sample indices in the current chunk. extra is an optional output argument that allows you to store any additional metadata. After the transformation function has been run on every chunk of the dataset, these individual extra outputs will be accumulated in a cell array by chunk. Modifying a dataset during copy to new location \u00b6 Once you\u2019ve written your transform function (or functions), you can run them on the dataset using: [ imecOut ] = imec . saveTransformedDataset ( outPath , 'transformAP' , { cell of function handles }, ... 'transformLF' , { cell of function handles }); Here, outPath should include the folder where the new datasets should be written. By default, the file stem (preceeding .ap.bin ) will match the leaf directory in outPath , but this can be specified manually by passing a stem parameter: [ imecOut ] = imec . saveTransformedDataset ( '/path/to/datasets/' , 'stem' , 'modifiedDataset' , ... ) % creates /path/to/datasets/modifiedDataset.ap.bin, .ap.meta, etc. You can provide one or more function handles (e.g. @npxutils.dataprocess.commonAverageReference ) that will be applied sequentially. Other optional parameters include: dryRun : If true, no actual data will be modified on disk, facilitating testing or step by step debugging of the transform functions before writing data. (default false). gpuArray : If true, the data chunks will be copied to the GPU and the transformation functions will receive and return GPU arrays. applyScaling : If true, the data will be converted to floating point values with the correct analog scale. if false (default) the data will remain in the original, unscaled int16 quantization. writeAP : If true, the AP file will be transformed and copied. writeLF : If true, the LF file will be transformed and copied (default false but will be set true automatically if any transformLF is non-empty). goodChannelsOnly : Send only the channels marked good to the transform function. connectedChannelsOnly : Send only the connected channels to the transform function. mappedChannelsOnly : Send only the mapped channels to the transform function. chunkSize : Specify the number of time samples sent to transform functions at once. extraMeta : A struct with extra meta fields to include or overwrite with the output file. timeShifts : A npxutils.TimeShiftSpec instance used to excise time windows, see excising time windows . Save transformed data to a new folder! Ensure that outPath refers to separate directory so that you make a copy of the dataset rather than writing over the same location. An error will be thrown if any existing files would be overwritten by this call. Modifying a dataset in place \u00b6 Rather than generate a copy, you can also modify a file in place if you\u2019re short on disk space, but be careful, as there\u2019s no undo if anything goes wrong. The same additional parameters are accepted, and you may wish to test your code first by passing 'dryRun', true . imec . modifyAPInPlace ( outPath , { cell of function handles }, ... ); imec . modifyLFInPlace ( outPath , { cell of function handles }, ... ); Concatenating multiple files together \u00b6 If you have multiple separate recording files that you wish to process and sort together, you can concatenate them together during the copy. The code will also scale the datasets up to a common gain factor if the file gains differ from each other. This will not of course increase the resolution of low-gain files, but it will ensure that the signal amplitudes match across files with different gains. imecList = { imec1 , imec2 , ... }; imecOut = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( imecList , outPath , ... 'transformAP' , { cell of function handles }, ... 'transformLF' , { cell of function handles }, ... ); Making copies and symbolic links \u00b6 You can generate a copy of a dataset using: [ imecOut ] = imec . saveTransformedDataset ( outPath , 'writeAP' , true , 'writeLF' , true ); Alternatively, you can create symbolic links to the AP bin and meta files in a new location using: imecLinked = imec . symLinkAPIntoDirectory ( outPath ); This is useful for running Kilosort with varying parameters, since each run would ideally live in its own directory but there\u2019s no need for a real copy of the raw data. Excising time windows \u00b6 Occasionally it can be beneficial to remove certain time windows from a file, or to omit them while plotting data. This may be accomplished using npxutils.TimeShiftSpec instances to indicate which windows of time to keep and how to shift them so as to remove gaps. A TimeShiftSpec specifies a list of sample intervals bounded by a start and stop index in properties idxStart and idxStop . The start index in idxStart will be shifted to lie at sample index idxShiftStart . You can calculate these shifts directly, but it is typically easier to specify only the sample intervals you wish to keep and then construct the TimeShiftSpec using: timeShifts = npxutils . TimeShiftSpec . buildToExciseGaps ( idxStartList , idxStopList ); If you have known trial boundaries in your file (see Segmenting a Kilosort dataset into trials for more information), you can also excise the regions of time far from trial boundaries using the TrialSegmentationInfo instance. I\u2019ve found this to be useful to exclude time windows where the subject was asleep from further analysis. timeShifts = tsi . computeShiftsExciseRegionsOutsideTrials ( 'maxPauseSec' , 20 ); You can then pass along this npxutils.TimeShiftSpec to any of the data transform functions. Depending on whether the timeShifts object was created in indices of AP band sample rate or LF band sample rate, you should pass it along as timeShiftsAP or timeShiftsLF . The conversion to the other sampling rate will be handled automatically so that the excision is performed on both datasets appropriately. imecOut = imec . saveTransformedDataset ( outPath , 'timeShiftsAP' , timeShifts , ... ); A cell array of npxutils.TimeShiftSpec instances can be provided when concatenating multiple files: imecOut = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( outPath , imecList , ... 'timeShiftsAP' , { timeShift1 , timeShift2 , ... }, ...); Referring to Source Datasets \u00b6 If helpful, when loading a derived ImecDataset , you can specify the sourceDatasets parameter to provide an array of ImecDataset instances corresponding to the original, pre-processed source datasets. Here, this would be the set of raw datasets provided as the imecList argument above. For certain methods, you can then pass parameter fromSourceDatasets , true and the corresponding window of time from the source datasets will be plotted instead of the processed data. This will automatically handle any time shifts and excisions performed; consequently it is helpful for debugging processing pipelines to see the before and after data. imecProcessed = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( outPath , imecList , ... ); imecProcessed = npxutils . ImecDataset ( outPath , 'sourceDatasets' , { imecRaw1 , imecRaw2 }); imecProcessed . inspectAP_timeWindow ([ 1 2 ], 'fromSourceDatasets' , true );","title":"Neuropixel.ImecDataset"},{"location":"imec_dataset.html#npxutilsimecdataset","text":"The npxutils.ImecDataset class wraps one individual recording session acquired with SpikeGLX. Currently, four files with extensions .imec.ap.bin , .imec.ap.meta , .imec.lf.bin , and .imec.lf.meta comprise one ImecDataset.","title":"npxutils.ImecDataset"},{"location":"imec_dataset.html#constructing-a-npxutilsimecdataset","text":"You construct a npxutils.ImecDataset by pointing it at the path to your dataset. How you specify the path is flexible. You can point directly at one of the files: imec = npxutils . ImecDataset ( '/data/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin' ); Or specify the common prefix to the .imec.* files comprising the dataset: imec = npxutils . ImecDataset ( '/data/raw_datasets/neuropixel_01_g0_t0' ); The common prefix can be shorter as long as there is no ambiguity: imec = npxutils . ImecDataset ( '/data/raw_datasets/neuropixel_01' ); You can also point at the parent directory as long as only one .ap.bin file is contained within. imec = npxutils . ImecDataset ( '/data/raw_datasets/' ); These are all equivalent, in that the resulting imec instance will wrap both AP and LF bin and meta files. (Though it\u2019s okay if the LF files are missing).","title":"Constructing a npxutils.ImecDataset"},{"location":"imec_dataset.html#specifying-a-channel-map","text":"When constructing the ImecDataset, you can specify a channel map. If you don\u2019t specify one, the default will be returned by npxutils.util.getDefaultChannelMapFile() , which in turn will look for the file pointed to by the environment variables 'NEUROPIXEL_MAP_FILE' or 'NPIX_MAP_FILE' . You can set these using Matlab\u2019s setenv function. These .mat files are expected to be in the same format as found on the neuropixels repo . For the phase 3A probe with 384 channels, the file neuropixPhase3A_kilosortChanMap.mat contains: >> ld = load ( 'neuropixPhase3A_kilosortChanMap.mat' ) struct with fields : chanMap : [ 384 \u00d7 1 double ] chanMap0ind : [ 384 \u00d7 1 double ] connected : [ 384 \u00d7 1 logical ] shankInd : [ 384 \u00d7 1 double ] xcoords : [ 384 \u00d7 1 double ] ycoords : [ 384 \u00d7 1 double ] You can construct a ChannelMap directly by pointing at the .mat file, although every function within neuropixel-utils will also accept the filename and construct the ChannelMap for you: chanMap = npxutils . ChannelMap ( mat_file_path ); Then you can use this map for an ImecDataset using: imec = npxutils . ImecDataset ( 'channelMap' , chanMap ); imec = npxutils . ImecDataset ( 'channelMap' , mat_file_path );","title":"Specifying a Channel Map"},{"location":"imec_dataset.html#exploring-metadata","text":"When the ImecDataset is created, the metadata are loaded from the .ap.meta file. You can request the full metadata using meta = imec . readAPMeta () struct with fields : acqApLfSy : [ 384 384 1 ] appVersion : 20171101 fileCreateTime : '2018-06-08T12:09:07' fileName : 'neuropixel_01_g0_t0.imec.ap.bin' fileSHA1 : '36E9F78B0725C15431E12DEC516A779A31643ED8' fileSizeBytes : 8.6557e+10 fileTimeSecs : 3.7471e+03 firstSample : 7060812 gateMode : 'Immediate' ... The most commonly accessed metadata is stored in properties of the ImecDataset: ImecDataset with properties: pathRoot : '/data/neuropixel/raw_datasets' % parent directories fileStem : 'neuropixel_01_g0_t0' % common prefix creationTime : 7.3722e+05 % datenum nChannels : 385 % total number of channels in the data file fileTypeAP : 'ap' % indicates the file suffix right before .bin, usually ap or ap_CAR nSamplesAP : 112412208 % number of time samples in the AP file nSamplesLF : 0 % number of time samples in the LF file (if present) fsAP : 30000 % sampling rate in Hz fsLF : NaN % sampling rate in Hz highPassFilterHz : 300 % online high pass filter pole (imHpFlt) apGain : 500 % AP gain selected apRange : [ - 0.6000 0.6000 ] % voltage range on ADC lfGain : 250 % LF gain selected lfRange : [ - 0.6000 0.6000 ] % voltage range on ADC adcBits : 10 % number of ADC bits used channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] % channel map for this recording syncChannelIndex : 385 % index of the sync channel if present in AP file syncInAPFile : 1 % whether the sync channels is present in the AP file badChannels : [ 3 \u00d7 1 double ] % list of channels marked as bad syncBitNames : [ 16 \u00d7 1 string ] % user-specified names of each sync bit for convenience syncRaw : [] % cached contents of sync if loaded bytesPerSample : 2 % currently fixed at 2 for int16 samples hasAP : 1 % was an associated AP file present? hasLF : 0 % was an associated LF file present? channelMapFile : '~/npl/neuropixel-utils/map_files/neuropixPhase3A_kilosortChanMap.mat' % full path to channel map file mappedChannels : [ 384 \u00d7 1 double ] % list of channel ids that have coordinates in the channel map nChannelsMapped : 384 connectedChannels : [ 374 \u00d7 1 double ] % list of channel ids that are connected to voltage pads nChannelsConnected : 374 goodChannels : [ 371 \u00d7 1 double ] % list of channel ids that are marked good (or not marked as bad) nGoodChannels : 371 channelIds : [ 384 \u00d7 1 double ] % list of channel ids present in the channel map channelNames : [ 385 \u00d7 1 string ] % autogenerated names for each channel channelNamesPadded : [ 385 \u00d7 1 string ] % autogenerated names for each channel, where numbers are padded with spaces nSyncBits : 16 syncBitsNamed : [ 8 \u00d7 1 double ] % which of the sync bits have user provided names fileAP : 'neuropixel_01_g0_t0.imec.ap.bin' pathAP : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin' fileAPMeta : 'neuropixel_01_g0_t0.imec.ap.meta' pathAPMeta : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.imec.ap.meta' fileLF : 'neuropixel_01_g0_t0.imec.lf.bin' pathLF : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.imec.lf.bin' fileLFMeta : 'neuropixel_01_g0_t0.imec.lf.meta' pathLFMeta : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.imec.lf.meta' fileSync : 'neuropixel_01_g0_t0.imec.ap.bin' pathSync : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin' fileSyncCached : 'neuropixel_01_g0_t0.sync.mat' % location where sync data will be cached for quick access pathSyncCached : '/data/neuropixel/raw_datasets/neuropixel_01_g0_t0.sync.mat' creationTimeStr : '08-Jun-2018 12:09:07' apScaleToUv : 2.3438 % conversion factor. Multiply raw AP int16s by this to get uV lfScaleToUv : 2.3438 % conversion factor. Multiply raw LF int16s by this to get uV","title":"Exploring metadata"},{"location":"imec_dataset.html#setting-sync-bit-names","text":"For convenience, if you use the sync bits for individual TTL signals during your recordings, you can set their names for the recording so that subsequent processing can refer to the bits by name rather than index. You may also find it useful to store additional data in some sync bits during subsequent processing, such as marking regions of time where an artifact was detected, such that specifying the bit by name is useful. Bits are ordered like bitget , i.e. 1 is the least significant bit. imec . setSyncBitNames ( 1 , \"trialStart\" ) The full set of sync bits is found in imec.syncBitNames , or you can lookup the bit corresponding to a given name using: idx = imec . lookupSyncBitByName ( \"trialStart\" )","title":"Setting sync bit names"},{"location":"imec_dataset.html#marking-bad-channels","text":"You can manually mark specific channels as bad using: imec . markBadChannels ( channelIds ); Use channel IDs, not indices Note that like all channel lists, channelIds is specified using the actual unique ids of each channel (as specified in the ChannelMap), which is not necessarily their index into the channel map if the channels are not contiguously numbered. You can use lookup_channelIds to find the channel indices for a given set of channel ids if needed: [ channelInds , channelIds ] = imec . lookup_channelIds ( channelIds ) One common task is marking channels as bad if their RMS voltage lies outside a reasonable range: imec . markBadChannelsByRMS ( 'rmsRange' , [ 3 100 ]); % [low high] range of RMS in uV The remaining \u201cgood\u201d channel ids can always be accessed using imec.goodChannels which will be the set of connected channels excluding the bad channels.","title":"Marking bad channels"},{"location":"imec_dataset.html#writing-modified-metadata-back-to-disk","text":"After making any modifications to the metadata, such as setting the sync bit names or marking bad channels, you can write it back to disk (in the .imec.ap.meta file) such that it will be reloaded automatically the next time you create an ImecDataset instance for that file. imec . writeModifiedAPMeta (); You can also append whatever fields you want to the meta file using the extraMeta parameter: extraMeta . cleaned = true ; extraMeta . cleaningAlgorithm = 'v1' ; imec . writeModifiedAPMeta ( 'extraMeta' , extraMeta );","title":"Writing modified metadata back to disk"},{"location":"imec_dataset.html#accessing-data","text":"","title":"Accessing data"},{"location":"imec_dataset.html#raw-memory-maps","text":"The most convenient way to access the data is to request a memory map: mmap = imec . memmapAP_full (); value = mmap . Data . x ( ch_index , sample_index ); % access a specific sample Equivalent functionality is available for LF files using imec.memmapLF_full() . If you wish to modify the underlying data file directly, you can also request a Writeable version of the memory map: mmap = imec . memmapAP_full ( 'Writable' , true ); mmap . Data . x ( ch_index , sample_index ) = new_value ; % overwrite a specific sample","title":"Raw memory maps"},{"location":"imec_dataset.html#reading-specific-time-window","text":"You can also request a specific sample or time window directly: idxWindow = [ idxFirst idxLast ]; [ data_partial , sampleIdx ] = imec . readAP_idx ( idxWindow ); timeWindow = [ secStart , secStop ]; % in seconds [ data_partial , sampleIdx ] = imec . readAP_timeWindow ( timeWindow );","title":"Reading specific time window"},{"location":"imec_dataset.html#plotting-specific-time-windows","text":"You can also quickly generate a stacked traces plot of a specific time window, optionally selecting which channels to plot. Take care to select a reasonable time window to avoid overwhelming your system. All channels are individually centered and then collectively normalized by the maximum value before plotting. You can change the global scaling factor by specifying gain > 1. imec . inspectAP_idxWindow ( idxWindow , ... ) imec . inspectAP_timeWindow ( timeWindow , ... ) There are additional optional parameters you can specify: channels : channel indices to plot, defaults to imec.mappedChannels . syncBits : which sync bits to plot individually, defaults to imec.syncBitsNamed . gain : global scaling factor, values larger then 1 will magnify the individual channels, defaults to 0.95. car : perform common average referencing before plotting, defaults to false. downsample : take every nth sample to speed up plotting, defaults to 1. Good channels are plotted in black, non-connected channels in blue, and bad channels in red. Sync bits are also shown in red and are not affected by the normalization gain.","title":"Plotting specific time windows"},{"location":"imec_dataset.html#reading-sync-channel","text":"You can access the sync channel all at once using: sync = imec . readSync (); trialStartBit = imec . readSyncBit ( \"trialStart\" ); Or a specific sample or time window using: [ sync_partial , sampleIdx ] = imec . readSync_idx ( idxWindow ); [ sync_partial , sampleIdx ] = imec . readSync_timeWindow ( timeWindow ); You can also access the logical values of specific bits either by bit index or name using: partial = imec . readSyncBits_idx ( bits_or_names , idxWindow ); % nTime x nBits trialStart_partial = imec . readSyncBits_idx ( \"trialStart\" , idxWindow ); % nTime x 1","title":"Reading sync channel"},{"location":"imec_dataset.html#building-a-preprocessing-pipeline","text":"If the raw .imec.ap.bin file must be processed in some way before running Kilosort, e.g. to remove artifacts, you can implement this efficiently by writing a transformation function that will act on chunks of the data. One example is found in npxutils.dataprocess.commonAverageReference : function [data, extra] = commonAverageReference ( imec, data, chIds, sampleIdx ) %#ok<INUSD> % chIds are the channel ids and imec.goodChannels is a list of channel ids % so this will lookup the channel indices of those channels both in chIdx that % are also marked as good. This prevents us from computing the reference % from the sync, reference, or bad channels. chanMask = imec . lookup_channelIds ( intersect ( chIds , imec . goodChannels )); % subtract median of each channel over time data ( chanMask , :) = bsxfun (@ minus , data ( chanMask , :), median ( data ( chanMask , :), 2 )); % subtract median across good channels data ( chanMask , :) = bsxfun (@ minus , data ( chanMask , :), median ( data ( chanMask , :), 1 )); end Essentially, your transform function can perform any modifications to the data matrix and return the resulting data matrix. Here, imec will be the ImecDataset being transformed, data will be the nChannels x nTime chunk of data being processed. chIds will be the channel ids (not necessarily their indices into data but the ids assigned by the channel map), and will typically be the full list of channel ids present in the data file. sampleIdx is the sample indices in the current chunk. extra is an optional output argument that allows you to store any additional metadata. After the transformation function has been run on every chunk of the dataset, these individual extra outputs will be accumulated in a cell array by chunk.","title":"Building a preprocessing pipeline"},{"location":"imec_dataset.html#modifying-a-dataset-during-copy-to-new-location","text":"Once you\u2019ve written your transform function (or functions), you can run them on the dataset using: [ imecOut ] = imec . saveTransformedDataset ( outPath , 'transformAP' , { cell of function handles }, ... 'transformLF' , { cell of function handles }); Here, outPath should include the folder where the new datasets should be written. By default, the file stem (preceeding .ap.bin ) will match the leaf directory in outPath , but this can be specified manually by passing a stem parameter: [ imecOut ] = imec . saveTransformedDataset ( '/path/to/datasets/' , 'stem' , 'modifiedDataset' , ... ) % creates /path/to/datasets/modifiedDataset.ap.bin, .ap.meta, etc. You can provide one or more function handles (e.g. @npxutils.dataprocess.commonAverageReference ) that will be applied sequentially. Other optional parameters include: dryRun : If true, no actual data will be modified on disk, facilitating testing or step by step debugging of the transform functions before writing data. (default false). gpuArray : If true, the data chunks will be copied to the GPU and the transformation functions will receive and return GPU arrays. applyScaling : If true, the data will be converted to floating point values with the correct analog scale. if false (default) the data will remain in the original, unscaled int16 quantization. writeAP : If true, the AP file will be transformed and copied. writeLF : If true, the LF file will be transformed and copied (default false but will be set true automatically if any transformLF is non-empty). goodChannelsOnly : Send only the channels marked good to the transform function. connectedChannelsOnly : Send only the connected channels to the transform function. mappedChannelsOnly : Send only the mapped channels to the transform function. chunkSize : Specify the number of time samples sent to transform functions at once. extraMeta : A struct with extra meta fields to include or overwrite with the output file. timeShifts : A npxutils.TimeShiftSpec instance used to excise time windows, see excising time windows . Save transformed data to a new folder! Ensure that outPath refers to separate directory so that you make a copy of the dataset rather than writing over the same location. An error will be thrown if any existing files would be overwritten by this call.","title":"Modifying a dataset during copy to new location"},{"location":"imec_dataset.html#modifying-a-dataset-in-place","text":"Rather than generate a copy, you can also modify a file in place if you\u2019re short on disk space, but be careful, as there\u2019s no undo if anything goes wrong. The same additional parameters are accepted, and you may wish to test your code first by passing 'dryRun', true . imec . modifyAPInPlace ( outPath , { cell of function handles }, ... ); imec . modifyLFInPlace ( outPath , { cell of function handles }, ... );","title":"Modifying a dataset in place"},{"location":"imec_dataset.html#concatenating-multiple-files-together","text":"If you have multiple separate recording files that you wish to process and sort together, you can concatenate them together during the copy. The code will also scale the datasets up to a common gain factor if the file gains differ from each other. This will not of course increase the resolution of low-gain files, but it will ensure that the signal amplitudes match across files with different gains. imecList = { imec1 , imec2 , ... }; imecOut = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( imecList , outPath , ... 'transformAP' , { cell of function handles }, ... 'transformLF' , { cell of function handles }, ... );","title":"Concatenating multiple files together"},{"location":"imec_dataset.html#making-copies-and-symbolic-links","text":"You can generate a copy of a dataset using: [ imecOut ] = imec . saveTransformedDataset ( outPath , 'writeAP' , true , 'writeLF' , true ); Alternatively, you can create symbolic links to the AP bin and meta files in a new location using: imecLinked = imec . symLinkAPIntoDirectory ( outPath ); This is useful for running Kilosort with varying parameters, since each run would ideally live in its own directory but there\u2019s no need for a real copy of the raw data.","title":"Making copies and symbolic links"},{"location":"imec_dataset.html#excising-time-windows","text":"Occasionally it can be beneficial to remove certain time windows from a file, or to omit them while plotting data. This may be accomplished using npxutils.TimeShiftSpec instances to indicate which windows of time to keep and how to shift them so as to remove gaps. A TimeShiftSpec specifies a list of sample intervals bounded by a start and stop index in properties idxStart and idxStop . The start index in idxStart will be shifted to lie at sample index idxShiftStart . You can calculate these shifts directly, but it is typically easier to specify only the sample intervals you wish to keep and then construct the TimeShiftSpec using: timeShifts = npxutils . TimeShiftSpec . buildToExciseGaps ( idxStartList , idxStopList ); If you have known trial boundaries in your file (see Segmenting a Kilosort dataset into trials for more information), you can also excise the regions of time far from trial boundaries using the TrialSegmentationInfo instance. I\u2019ve found this to be useful to exclude time windows where the subject was asleep from further analysis. timeShifts = tsi . computeShiftsExciseRegionsOutsideTrials ( 'maxPauseSec' , 20 ); You can then pass along this npxutils.TimeShiftSpec to any of the data transform functions. Depending on whether the timeShifts object was created in indices of AP band sample rate or LF band sample rate, you should pass it along as timeShiftsAP or timeShiftsLF . The conversion to the other sampling rate will be handled automatically so that the excision is performed on both datasets appropriately. imecOut = imec . saveTransformedDataset ( outPath , 'timeShiftsAP' , timeShifts , ... ); A cell array of npxutils.TimeShiftSpec instances can be provided when concatenating multiple files: imecOut = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( outPath , imecList , ... 'timeShiftsAP' , { timeShift1 , timeShift2 , ... }, ...);","title":"Excising time windows"},{"location":"imec_dataset.html#referring-to-source-datasets","text":"If helpful, when loading a derived ImecDataset , you can specify the sourceDatasets parameter to provide an array of ImecDataset instances corresponding to the original, pre-processed source datasets. Here, this would be the set of raw datasets provided as the imecList argument above. For certain methods, you can then pass parameter fromSourceDatasets , true and the corresponding window of time from the source datasets will be plotted instead of the processed data. This will automatically handle any time shifts and excisions performed; consequently it is helpful for debugging processing pipelines to see the before and after data. imecProcessed = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( outPath , imecList , ... ); imecProcessed = npxutils . ImecDataset ( outPath , 'sourceDatasets' , { imecRaw1 , imecRaw2 }); imecProcessed . inspectAP_timeWindow ([ 1 2 ], 'fromSourceDatasets' , true );","title":"Referring to Source Datasets"},{"location":"kilosort.html","text":"Running Kilosort 1/2 and loading the results \u00b6 KilosortDataset is a wrapper around the output of Kilosort or Kilosort2, which will load the output files back into Matlab for further analysis. Most of these fields are explained in detail in the Phy documentation but we document them here for convenience. Running Kilosort \u00b6 To run Kilosort or Kilosort2 on an ImecDataset: npxutils . runKilosort1 ( imec , ... ); Or for Kilosort 2: npxutils . runKilosort2 ( imec , ... ); By default, the standard configuration settings will be used. For Kilosort1, these are hardcoded based on configFiles/StandardConfig_MOVEME.m . For Kilosort2, the script configFiles/configFile384.m will be run to produce the ops struct, unless a different configuration file is set in the environment variable KILOSORT_CONFIG_FILE , which must be on the path. Default configuration settings can be overridden by passing in extra parameters, e.g. npxutils . runKilosort1 ( imec , 'Th' , [ 4 10 ], 'GPU' , false ); npxutils . runKilosort2 ( imec , 'minfr_goodchannels' , 0.1 ); Loading Kilosort results \u00b6 You can create a KilosortDataset instance by pointing at the folder containing the Kilosort output: ks = npxutils . KilosortDataset ( pathToKilosortOutput (); ks . load (); The constructor will optionally take an \u2018imecDataset\u2019 parameter providing the npxutils.ImecDataset instance if there is no .imec.ap.bin file in the Kilosort directory, and a \u2018channelMap\u2019 parameter in case the default is not correct. The results can then be loaded using ks.load() . The descriptions of each property can be found in the +Neuropixel/KilosortDataset.m code, copied here for convenience, originally described in the Phy documentation : >> ks KilosortDataset with properties: path : '/data/kilosort/neuropixel_01' raw_dataset : [ 1 \u00d7 1 npxutils . ImecDataset ] channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] fsAP : 30000 apScaleToUv : 2.3438 meta : [ 1 \u00d7 1 struct ] pathLeaf : 'neuropixel_01' isLoaded : 1 hasRawDataset : 1 nChannels : 371 nSpikes : 8181228 nClusters : 592 nTemplates : 653 nPCFeatures : 32 nFeaturesPerChannel : 3 syncBitNames : [ 16 \u00d7 1 string ] dat_path : 'neuropixel_01.imec.ap.bin' n_channels_dat : 385 dtype : 'int16' offset : 0 sample_rate : 30000 hp_filtered : 0 amplitudes : [ nSpikes \u00d7 1 double ] channel_ids : [ nChannels \u00d7 1 uint32 ] channel_positions : [ nChannels \u00d7 2 double ] pc_features : [ nSpikes \u00d7 nFeaturesPerChannel \u00d7 nPCFeatures single ] pc_feature_ind : [ nTemplates \u00d7 nPCFeatures uint32 ] similar_templates : [ nTemplates \u00d7 nTemplates single ] spike_templates : [ nSpikes \u00d7 1 uint32 ] spike_times : [ nSpikes \u00d7 1 uint64 ] template_features : [ nSpikes \u00d7 nPCFeatures single ] template_feature_ind : [ nTemplates \u00d7 nPCFeatures uint32 ] templates : [ nTemplates \u00d7 nTimePoints \u00d7 nChannels single ] templates_ind : [ nTemplates \u00d7 nChannels double ] whitening_mat : [ nChannels \u00d7 nChannels double ] whitening_mat_inv : [ nChannels \u00d7 nChannels double ] spike_clusters : [ nSpikes \u00d7 1 uint32 ] cluster_groups : [ nClusters \u00d7 1 categorical ] cluster_ids : [ nClusters \u00d7 1 uint32 ] clusters_good : [ nClustersGood \u00d7 1 uint32 ] clusters_mua : [ nClustersMUA \u00d7 1 uint32 ] clusters_noise : [ nClustersNoise \u00d7 1 uint32 ] clusters_unsorted : [ nClustersUnsorted \u00d7 1 uint32 ] nChannels : number of channels used by Kilosort nSpikes : number of spikes extracted nClusters : number of unique clusters nTemplates : number of spike templates nPCFeatures number of spatiotemporal PC features used for templates nFeaturesPerChannel : number of PC features used for each channel amplitudes - [nSpikes] double vector with the amplitude scaling factor that was applied to the template when extracting that spike channel_ids - [nChannels] uint32 vector with the channel ids used for sorting channel_positions - [nChannels, 2] double matrix with each row giving the x and y coordinates of that channel. Together with the channel map, this determines how waveforms will be plotted in WaveformView (see below). pc_features - [nSpikes, nFeaturesPerChannel, nPCFeatures] single matrix giving the PC values for each spike. The channels that those features came from are specified in pc_features_ind. E.g. the value at pc_features[123, 1, 5] is the projection of the 123rd spike onto the 1st PC on the channel given by pc_feature_ind[5]. pc_feature_ind - [nTemplates, nPCFeatures] uint32 matrix specifying which channels contribute to each entry in dim 3 of the pc_features matrix similar_templates - [nTemplates, nTemplates] single matrix giving the similarity score (larger is more similar) between each pair of templates similar_templates(:, :) single spike_templates - [nSpikes] uint32 vector specifying the identity of the template that was used to extract each spike spike_times - [nSpikes] uint64 vector giving the spike time of each spike in samples. To convert to seconds, divide by sample_rate from params.py. template_features - [nSpikes, nTempFeatures] single matrix giving the magnitude of the projection of each spike onto nTempFeatures other features. Which other features is specified in template_feature_ind. template_feature_ind - [nTemplates, nTempFeatures] uint32 matrix specifying which templateFeatures are included in the template_features matrix. templates - [nTemplates, nTimePoints, nTemplateChannels] single matrix giving the template shapes on the channels given in templates_ind templates_ind - [nTemplates, nTempChannels] double matrix specifying the channels on which each template is defined. In the case of Kilosort templates_ind is just the integers from 0 to nChannels-1, since templates are defined on all channels. whitening_mat - [nChannels, nChannels] double whitening matrix applied to the data during automatic spike sorting whitening_mat_inv - [nChannels, nChannels] double, the inverse of the whitening matrix. spike_clusters - [nSpikes] uint32 vector giving the cluster identity of each spike. cluster_groups - [nClusters] categorical vector giving the \u201ccluster group\u201d of each cluster (noise, mua, good, unsorted) cluster_ids - [nClusters] unique clusters in spike_clusters Segmenting a Kilosort dataset into trials \u00b6 ks.spike_times contains the times for each spike in samples from the beginning of the file, but there is a more useful representation for data collected with a trial structure: split the spikes into separate groups based on which trial they occurred in, and convert the times to milliseconds since the start of the trial. TrialSegmentationInfo \u00b6 In order to do this, you need to figure out where trials start and stop. You\u2019ll need to write this code, since this will differ for each experimental setup. Essentially, you need to create a npxutils.TrialSegmentationInfo instance and populate its fields with the correct values: tsi = npxutils . TrialSegmentationInfo ( nTrials , fsAP ); tsi . idxStart = [ list of start sample indices ] tsi . idxStop = [ list of stop sample indices ]; tsi . trialId = [ list of trial ids ]; Here is an example script that uses the sync channel to determine where trials begin and end. It expects one bit (named 'trialStart' ) to contain TTL pulses each time a trial starts, and another bit (named 'trialInfo' ) to contain ASCII-serialized bits of text occurring at the start of each trial. For example, the string id=1;c=2 would correspond to trialId=1 and conditionId=2 . It also assumes that a trial ends when the next trial begins (or at the end of the file). Long trials can be subsequently truncated using tsi.truncateTrialsLongerThan(maxDurationSeconds) . function tsi = parseTrialInfoFromSync ( syncRaw, fs, syncBitNames ) % fs is in samples per second % parses the sync line of an neuropixel .imec.ap.bin data file % and produces a scalar TrialSegmentationInfo % parse the sync if isempty ( syncBitNames ) trialInfoBitNum = 1 ; trialStartBitNum = 2 ; else [ tf , trialInfoBitNum ] = ismember ( 'trialInfo' , syncBitNames ); if ~ tf , trialInfoBitNum = 1 ; end [ tf , trialStartBitNum ] = ismember ( 'trialStart' , syncBitNames ); if ~ tf , trialStartBitNum = 1 ; end end serialBit = bitget ( syncRaw , trialInfoBitNum ); trialStart = bitget ( syncRaw , trialStartBitNum ); % trials start when going high idxStart = find ( diff ( trialStart ) == 1 ) + 1 ; nTrials = numel ( idxStart ); tsi = npxutils . TrialSegmentationInfo ( nTrials , fs ); samplesEachBit = round ( fs / 1000 ); % each bit delivered per ms for iR = 1 : nTrials if iR < nTrials idxNext = idxStart ( iR + 1 ) - 1 ; else idxNext = numel ( serialBit ); end bitsByTrial = uint8 ( serialBit ( floor ( samplesEachBit / 2 ) + idxStart ( iR ) : samplesEachBit : idxNext )); lastHigh = find ( bitsByTrial , 1 , 'last' ); lastHigh = ceil ( lastHigh / 8 ) * 8 ; bitsByTrial = bitsByTrial ( 1 : lastHigh ); infoThis = parseInfoString ( bitsToString ( bitsByTrial )); if isfield ( infoThis , 'id' ) tsi . trialId ( iR ) = str2double ( infoThis . id ); %#ok<*AGROW> else tsi . trialId ( iR ) = NaN ; end if isfield ( infoThis , 'c' ) tsi . conditionId ( iR ) = str2double ( infoThis . c ); else tsi . conditionId ( iR ) = NaN ; end tsi . idxStart ( iR ) = idxStart ( iR ); tsi . idxStop ( iR ) = idxNext ; end function out = bitsToString ( bits ) nChar = numel ( bits ) / 8 ; assert ( nChar == round ( nChar ), 'Bit length must be multiple of 8' ); out = blanks ( nChar ); for iC = 1 : nChar idx = ( 1 : 8 ) + ( iC - 1 ) * 8 ; out ( iC ) = char ( bin2dec ( sprintf ( '%u' , bits ( idx )))); end end function out = parseInfoString ( str ) keyval = regexp ( str , '(?<key>\\w+)=(?<value>[\\d\\.]+)' , 'names' ); if isempty ( keyval ) warning ( 'Could not parse info string \"%s\"' , str ); out = struct (); else for i = 1 : numel ( keyval ) out .( keyval ( i ). key ) = keyval ( i ). value ; end end end end KilosortTrialSegmentedDataset \u00b6 Once you have the trial boundaries stored in your TrialSegmentationInfo instance, you can split the properties of the KilosortDataset into each trial, resulting in a npxutils.KilosortTrialSegmentedDataset instance. To facilitate merging this into another data structure later, you will need to specify the ultimate trialId order you want the KilosortTrialSegmentedDataset to have. For example, if you have a behavioral data structure, you can extract the list of trial ids from that so that your KilosortTrialSegmentedDataset will have a matching trial sequence. trialIds = cat ( 1 , behaviorStruct . trialId ); Any trials not found in the TrialSegmentationInfo will simply be empty in the KilosortTrialSegmentedDataset . If you simply want to preserve the trials in the order they are in tsi , you can simply use: trialIds = tsi . trialIds ; You can then segment the KilosortDataset using: >> seg = npxutils . KilosortTrialSegmentedDataset ( ks , tsi , trial_ids ) KilosortTrialSegmentedDataset with properties: dataset : [ 1 \u00d7 1 npxutils . KilosortDataset ] % unsegmented KilosortDataset trial_ids : [ nTrials \u00d7 1 uint32 ] % trial ids trial_has_data : [ nTrials \u00d7 1 logical ] % indicator if trial found in tsi trial_start : [ nTrials \u00d7 1 uint64 ] % nTrials start sample idx copied from tsi trial_stop : [ nTrials \u00d7 1 uint64 ] % nTrials start sample idx copied from tsi spike_idx : { nTrials \u00d7 nClusters cell } % nTrials x nClusters lists of indices into ks.spike_times array for each spike cluster_ids : [ nClusters \u00d7 1 uint32 ] % copied from ks cluster_groups : [ nClusters \u00d7 1 categorical ] % copied from ks sync : { 1 \u00d7 1 cell } % segmented contents of sync channel syncBitNames : [ 16 \u00d7 1 string ] % copied from ImecDataset raw_dataset : [ 1 \u00d7 1 npxutils . ImecDataset ] % original ImecDataset copied from ks nTrials : 1092 % number of trials as numel(trialIds) nTrialsHaveData : 1092 % number of trials with matching trialIds in tsi nClusters : 592 % number of clusters (sorted units) nChannelsSorted : 385 % number of channels channel_ids : [ nChannelsSorted \u00d7 1 unit32 ] % list of channel ids used for sorting trial_duration_ms : [ nTrials \u00d7 1 double ] fsAP : 30000 amplitudes : { nTrials \u00d7 nClusters cell } % each of these will contain a vector with one entry for each spike from that cluster on that trial pc_features : { nTrials \u00d7 nClusters cell } spike_times : { nTrials \u00d7 nClusters cell } % raw sample times from ks spike_times_ms_rel_start : { nTrials \u00d7 nClusters cell } % times from trial start in milliseconds template_features : { nTrials \u00d7 nClusters cell } spike_templates : { nTrials \u00d7 nClusters cell }","title":"Running Kilosort"},{"location":"kilosort.html#running-kilosort-12-and-loading-the-results","text":"KilosortDataset is a wrapper around the output of Kilosort or Kilosort2, which will load the output files back into Matlab for further analysis. Most of these fields are explained in detail in the Phy documentation but we document them here for convenience.","title":"Running Kilosort 1/2 and loading the results"},{"location":"kilosort.html#running-kilosort","text":"To run Kilosort or Kilosort2 on an ImecDataset: npxutils . runKilosort1 ( imec , ... ); Or for Kilosort 2: npxutils . runKilosort2 ( imec , ... ); By default, the standard configuration settings will be used. For Kilosort1, these are hardcoded based on configFiles/StandardConfig_MOVEME.m . For Kilosort2, the script configFiles/configFile384.m will be run to produce the ops struct, unless a different configuration file is set in the environment variable KILOSORT_CONFIG_FILE , which must be on the path. Default configuration settings can be overridden by passing in extra parameters, e.g. npxutils . runKilosort1 ( imec , 'Th' , [ 4 10 ], 'GPU' , false ); npxutils . runKilosort2 ( imec , 'minfr_goodchannels' , 0.1 );","title":"Running Kilosort"},{"location":"kilosort.html#loading-kilosort-results","text":"You can create a KilosortDataset instance by pointing at the folder containing the Kilosort output: ks = npxutils . KilosortDataset ( pathToKilosortOutput (); ks . load (); The constructor will optionally take an \u2018imecDataset\u2019 parameter providing the npxutils.ImecDataset instance if there is no .imec.ap.bin file in the Kilosort directory, and a \u2018channelMap\u2019 parameter in case the default is not correct. The results can then be loaded using ks.load() . The descriptions of each property can be found in the +Neuropixel/KilosortDataset.m code, copied here for convenience, originally described in the Phy documentation : >> ks KilosortDataset with properties: path : '/data/kilosort/neuropixel_01' raw_dataset : [ 1 \u00d7 1 npxutils . ImecDataset ] channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] fsAP : 30000 apScaleToUv : 2.3438 meta : [ 1 \u00d7 1 struct ] pathLeaf : 'neuropixel_01' isLoaded : 1 hasRawDataset : 1 nChannels : 371 nSpikes : 8181228 nClusters : 592 nTemplates : 653 nPCFeatures : 32 nFeaturesPerChannel : 3 syncBitNames : [ 16 \u00d7 1 string ] dat_path : 'neuropixel_01.imec.ap.bin' n_channels_dat : 385 dtype : 'int16' offset : 0 sample_rate : 30000 hp_filtered : 0 amplitudes : [ nSpikes \u00d7 1 double ] channel_ids : [ nChannels \u00d7 1 uint32 ] channel_positions : [ nChannels \u00d7 2 double ] pc_features : [ nSpikes \u00d7 nFeaturesPerChannel \u00d7 nPCFeatures single ] pc_feature_ind : [ nTemplates \u00d7 nPCFeatures uint32 ] similar_templates : [ nTemplates \u00d7 nTemplates single ] spike_templates : [ nSpikes \u00d7 1 uint32 ] spike_times : [ nSpikes \u00d7 1 uint64 ] template_features : [ nSpikes \u00d7 nPCFeatures single ] template_feature_ind : [ nTemplates \u00d7 nPCFeatures uint32 ] templates : [ nTemplates \u00d7 nTimePoints \u00d7 nChannels single ] templates_ind : [ nTemplates \u00d7 nChannels double ] whitening_mat : [ nChannels \u00d7 nChannels double ] whitening_mat_inv : [ nChannels \u00d7 nChannels double ] spike_clusters : [ nSpikes \u00d7 1 uint32 ] cluster_groups : [ nClusters \u00d7 1 categorical ] cluster_ids : [ nClusters \u00d7 1 uint32 ] clusters_good : [ nClustersGood \u00d7 1 uint32 ] clusters_mua : [ nClustersMUA \u00d7 1 uint32 ] clusters_noise : [ nClustersNoise \u00d7 1 uint32 ] clusters_unsorted : [ nClustersUnsorted \u00d7 1 uint32 ] nChannels : number of channels used by Kilosort nSpikes : number of spikes extracted nClusters : number of unique clusters nTemplates : number of spike templates nPCFeatures number of spatiotemporal PC features used for templates nFeaturesPerChannel : number of PC features used for each channel amplitudes - [nSpikes] double vector with the amplitude scaling factor that was applied to the template when extracting that spike channel_ids - [nChannels] uint32 vector with the channel ids used for sorting channel_positions - [nChannels, 2] double matrix with each row giving the x and y coordinates of that channel. Together with the channel map, this determines how waveforms will be plotted in WaveformView (see below). pc_features - [nSpikes, nFeaturesPerChannel, nPCFeatures] single matrix giving the PC values for each spike. The channels that those features came from are specified in pc_features_ind. E.g. the value at pc_features[123, 1, 5] is the projection of the 123rd spike onto the 1st PC on the channel given by pc_feature_ind[5]. pc_feature_ind - [nTemplates, nPCFeatures] uint32 matrix specifying which channels contribute to each entry in dim 3 of the pc_features matrix similar_templates - [nTemplates, nTemplates] single matrix giving the similarity score (larger is more similar) between each pair of templates similar_templates(:, :) single spike_templates - [nSpikes] uint32 vector specifying the identity of the template that was used to extract each spike spike_times - [nSpikes] uint64 vector giving the spike time of each spike in samples. To convert to seconds, divide by sample_rate from params.py. template_features - [nSpikes, nTempFeatures] single matrix giving the magnitude of the projection of each spike onto nTempFeatures other features. Which other features is specified in template_feature_ind. template_feature_ind - [nTemplates, nTempFeatures] uint32 matrix specifying which templateFeatures are included in the template_features matrix. templates - [nTemplates, nTimePoints, nTemplateChannels] single matrix giving the template shapes on the channels given in templates_ind templates_ind - [nTemplates, nTempChannels] double matrix specifying the channels on which each template is defined. In the case of Kilosort templates_ind is just the integers from 0 to nChannels-1, since templates are defined on all channels. whitening_mat - [nChannels, nChannels] double whitening matrix applied to the data during automatic spike sorting whitening_mat_inv - [nChannels, nChannels] double, the inverse of the whitening matrix. spike_clusters - [nSpikes] uint32 vector giving the cluster identity of each spike. cluster_groups - [nClusters] categorical vector giving the \u201ccluster group\u201d of each cluster (noise, mua, good, unsorted) cluster_ids - [nClusters] unique clusters in spike_clusters","title":"Loading Kilosort results"},{"location":"kilosort.html#segmenting-a-kilosort-dataset-into-trials","text":"ks.spike_times contains the times for each spike in samples from the beginning of the file, but there is a more useful representation for data collected with a trial structure: split the spikes into separate groups based on which trial they occurred in, and convert the times to milliseconds since the start of the trial.","title":"Segmenting a Kilosort dataset into trials"},{"location":"kilosort.html#trialsegmentationinfo","text":"In order to do this, you need to figure out where trials start and stop. You\u2019ll need to write this code, since this will differ for each experimental setup. Essentially, you need to create a npxutils.TrialSegmentationInfo instance and populate its fields with the correct values: tsi = npxutils . TrialSegmentationInfo ( nTrials , fsAP ); tsi . idxStart = [ list of start sample indices ] tsi . idxStop = [ list of stop sample indices ]; tsi . trialId = [ list of trial ids ]; Here is an example script that uses the sync channel to determine where trials begin and end. It expects one bit (named 'trialStart' ) to contain TTL pulses each time a trial starts, and another bit (named 'trialInfo' ) to contain ASCII-serialized bits of text occurring at the start of each trial. For example, the string id=1;c=2 would correspond to trialId=1 and conditionId=2 . It also assumes that a trial ends when the next trial begins (or at the end of the file). Long trials can be subsequently truncated using tsi.truncateTrialsLongerThan(maxDurationSeconds) . function tsi = parseTrialInfoFromSync ( syncRaw, fs, syncBitNames ) % fs is in samples per second % parses the sync line of an neuropixel .imec.ap.bin data file % and produces a scalar TrialSegmentationInfo % parse the sync if isempty ( syncBitNames ) trialInfoBitNum = 1 ; trialStartBitNum = 2 ; else [ tf , trialInfoBitNum ] = ismember ( 'trialInfo' , syncBitNames ); if ~ tf , trialInfoBitNum = 1 ; end [ tf , trialStartBitNum ] = ismember ( 'trialStart' , syncBitNames ); if ~ tf , trialStartBitNum = 1 ; end end serialBit = bitget ( syncRaw , trialInfoBitNum ); trialStart = bitget ( syncRaw , trialStartBitNum ); % trials start when going high idxStart = find ( diff ( trialStart ) == 1 ) + 1 ; nTrials = numel ( idxStart ); tsi = npxutils . TrialSegmentationInfo ( nTrials , fs ); samplesEachBit = round ( fs / 1000 ); % each bit delivered per ms for iR = 1 : nTrials if iR < nTrials idxNext = idxStart ( iR + 1 ) - 1 ; else idxNext = numel ( serialBit ); end bitsByTrial = uint8 ( serialBit ( floor ( samplesEachBit / 2 ) + idxStart ( iR ) : samplesEachBit : idxNext )); lastHigh = find ( bitsByTrial , 1 , 'last' ); lastHigh = ceil ( lastHigh / 8 ) * 8 ; bitsByTrial = bitsByTrial ( 1 : lastHigh ); infoThis = parseInfoString ( bitsToString ( bitsByTrial )); if isfield ( infoThis , 'id' ) tsi . trialId ( iR ) = str2double ( infoThis . id ); %#ok<*AGROW> else tsi . trialId ( iR ) = NaN ; end if isfield ( infoThis , 'c' ) tsi . conditionId ( iR ) = str2double ( infoThis . c ); else tsi . conditionId ( iR ) = NaN ; end tsi . idxStart ( iR ) = idxStart ( iR ); tsi . idxStop ( iR ) = idxNext ; end function out = bitsToString ( bits ) nChar = numel ( bits ) / 8 ; assert ( nChar == round ( nChar ), 'Bit length must be multiple of 8' ); out = blanks ( nChar ); for iC = 1 : nChar idx = ( 1 : 8 ) + ( iC - 1 ) * 8 ; out ( iC ) = char ( bin2dec ( sprintf ( '%u' , bits ( idx )))); end end function out = parseInfoString ( str ) keyval = regexp ( str , '(?<key>\\w+)=(?<value>[\\d\\.]+)' , 'names' ); if isempty ( keyval ) warning ( 'Could not parse info string \"%s\"' , str ); out = struct (); else for i = 1 : numel ( keyval ) out .( keyval ( i ). key ) = keyval ( i ). value ; end end end end","title":"TrialSegmentationInfo"},{"location":"kilosort.html#kilosorttrialsegmenteddataset","text":"Once you have the trial boundaries stored in your TrialSegmentationInfo instance, you can split the properties of the KilosortDataset into each trial, resulting in a npxutils.KilosortTrialSegmentedDataset instance. To facilitate merging this into another data structure later, you will need to specify the ultimate trialId order you want the KilosortTrialSegmentedDataset to have. For example, if you have a behavioral data structure, you can extract the list of trial ids from that so that your KilosortTrialSegmentedDataset will have a matching trial sequence. trialIds = cat ( 1 , behaviorStruct . trialId ); Any trials not found in the TrialSegmentationInfo will simply be empty in the KilosortTrialSegmentedDataset . If you simply want to preserve the trials in the order they are in tsi , you can simply use: trialIds = tsi . trialIds ; You can then segment the KilosortDataset using: >> seg = npxutils . KilosortTrialSegmentedDataset ( ks , tsi , trial_ids ) KilosortTrialSegmentedDataset with properties: dataset : [ 1 \u00d7 1 npxutils . KilosortDataset ] % unsegmented KilosortDataset trial_ids : [ nTrials \u00d7 1 uint32 ] % trial ids trial_has_data : [ nTrials \u00d7 1 logical ] % indicator if trial found in tsi trial_start : [ nTrials \u00d7 1 uint64 ] % nTrials start sample idx copied from tsi trial_stop : [ nTrials \u00d7 1 uint64 ] % nTrials start sample idx copied from tsi spike_idx : { nTrials \u00d7 nClusters cell } % nTrials x nClusters lists of indices into ks.spike_times array for each spike cluster_ids : [ nClusters \u00d7 1 uint32 ] % copied from ks cluster_groups : [ nClusters \u00d7 1 categorical ] % copied from ks sync : { 1 \u00d7 1 cell } % segmented contents of sync channel syncBitNames : [ 16 \u00d7 1 string ] % copied from ImecDataset raw_dataset : [ 1 \u00d7 1 npxutils . ImecDataset ] % original ImecDataset copied from ks nTrials : 1092 % number of trials as numel(trialIds) nTrialsHaveData : 1092 % number of trials with matching trialIds in tsi nClusters : 592 % number of clusters (sorted units) nChannelsSorted : 385 % number of channels channel_ids : [ nChannelsSorted \u00d7 1 unit32 ] % list of channel ids used for sorting trial_duration_ms : [ nTrials \u00d7 1 double ] fsAP : 30000 amplitudes : { nTrials \u00d7 nClusters cell } % each of these will contain a vector with one entry for each spike from that cluster on that trial pc_features : { nTrials \u00d7 nClusters cell } spike_times : { nTrials \u00d7 nClusters cell } % raw sample times from ks spike_times_ms_rel_start : { nTrials \u00d7 nClusters cell } % times from trial start in milliseconds template_features : { nTrials \u00d7 nClusters cell } spike_templates : { nTrials \u00d7 nClusters cell }","title":"KilosortTrialSegmentedDataset"},{"location":"waveforms.html","text":"Extracting raw waveforms \u00b6 Extracting datasnippets from ImecDataset \u00b6 It is often useful to extract small windows of time from the raw data on each channel. Given a list of sample indices times you want to extract a window of time around, and a window = [offsetPre, offsetPost] of relative samples to collect around those times, you can do the following: >> times = 1e5 : 1e5 : 1e6 ; >> window = [ - 1000 , 999 ]; % 1000 samples before plus 999 samples after >> snippetSet = imec . readAPSnippetSet ( times , window ) snippetSet = SnippetSet with properties : data : [ 384 \u00d7 2000 \u00d7 10 int16 ] % nChannels x nTimepoints x nSnippets snippet data cluster_ids : [ 10 \u00d7 1 uint32 ] channel_ids_by_cluster : [ 384 \u00d7 1 uint32 ] % nChannels x nClusters channel ids, which channel ids were extracted for each cluster unique_cluster_idx : 1 sample_idx : [ 10 \u00d7 1 uint64 ] trial_idx : [ 0 \u00d7 1 uint32 ] window : [ - 1000 999 ] valid : [ 10 \u00d7 1 logical ] channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] scaleToUv : 2.3438 fs : 30000 nChannels : 384 nTimepoints : 2000 nSnippets : 10 nClusters : 1 data_valid : [ 384 \u00d7 2000 \u00d7 10 int16 ] Extracting waveforms via KilosortDataset \u00b6 With this functionality in place, it is very easy to extract raw waveforms from the original ImecDataset guided by a KilosortDataset to provide the spike times. From a KilosortDataset , you can request waveforms based on one of: spike_idx : index directly into spike_times spike_times : find spikes that match times in spike_times cluster_ids : find all spikes from a given cluster. Often, you would also specify 'num_waveforms' to cap the total number of waveforms per cluster via random sample, unless you want every spike for those clusters By default, waveforms will be extracted for every channel on the probe, unless you request specific channel_ids_by_cluster as a nClusters x nChannels matrix, or specify best_n_channels which will pick the best channels separately for each cluster. snippetSet = ks . getWaveformsFromRawData ( 'cluster_ids' , cluster_id , ... 'num_waveforms' , 50 , 'best_n_channels' , 20 , 'car' , true ); snippetSet . plotAtProbeLocations ( 'alpha' , 0.8 ); As you can see, there are other waveforms in the background corrupting these extracted waveforms. We can use the other Kilosort detected spike times and their respective templates to automatically clean these waveforms by subtracting the appropriate template at the appropriate times. snippetSet = ks . getWaveformsFromRawData ( 'cluster_ids' , cluster_id , ... 'num_waveforms' , 50 , 'best_n_channels' , 20 , 'car' , true , ... 'subtractOtherClusters' , true ); snippetSet . plotAtProbeLocations ( 'alpha' , 0.8 ); Extracting waveforms via KilosortTrialSegmentedDataset \u00b6 If you have already segmented the data into trials , you might wish to extract these waveforms for specific trials or even specific time windows within a trial, e.g. to check for behaviorally-triggered probe movement. For example, this will extract all spikes that occurred in the first 50 ms of each trial: cluster_ind = seg . lookup_clusterIds ( cluster_id ); mask_by_trial = cell ( seg . nTrials , 1 ); for iTrial = 1 : seg . nTrials mask_by_trial { iTrial } = seg . spike_times_ms_rel_start { iTrial , cluster_ind } < 50 ; end snippetSet = seg . getWaveformsFromRawData ( 'mask_cell' , mask_by_trial , 'cluster_id' , cluster_id , ... 'best_n_channels' , 20 , 'subtractOtherClusters' , true );","title":"Extracting Waveforms"},{"location":"waveforms.html#extracting-raw-waveforms","text":"","title":"Extracting raw waveforms"},{"location":"waveforms.html#extracting-datasnippets-from-imecdataset","text":"It is often useful to extract small windows of time from the raw data on each channel. Given a list of sample indices times you want to extract a window of time around, and a window = [offsetPre, offsetPost] of relative samples to collect around those times, you can do the following: >> times = 1e5 : 1e5 : 1e6 ; >> window = [ - 1000 , 999 ]; % 1000 samples before plus 999 samples after >> snippetSet = imec . readAPSnippetSet ( times , window ) snippetSet = SnippetSet with properties : data : [ 384 \u00d7 2000 \u00d7 10 int16 ] % nChannels x nTimepoints x nSnippets snippet data cluster_ids : [ 10 \u00d7 1 uint32 ] channel_ids_by_cluster : [ 384 \u00d7 1 uint32 ] % nChannels x nClusters channel ids, which channel ids were extracted for each cluster unique_cluster_idx : 1 sample_idx : [ 10 \u00d7 1 uint64 ] trial_idx : [ 0 \u00d7 1 uint32 ] window : [ - 1000 999 ] valid : [ 10 \u00d7 1 logical ] channelMap : [ 1 \u00d7 1 npxutils . ChannelMap ] scaleToUv : 2.3438 fs : 30000 nChannels : 384 nTimepoints : 2000 nSnippets : 10 nClusters : 1 data_valid : [ 384 \u00d7 2000 \u00d7 10 int16 ]","title":"Extracting datasnippets from ImecDataset"},{"location":"waveforms.html#extracting-waveforms-via-kilosortdataset","text":"With this functionality in place, it is very easy to extract raw waveforms from the original ImecDataset guided by a KilosortDataset to provide the spike times. From a KilosortDataset , you can request waveforms based on one of: spike_idx : index directly into spike_times spike_times : find spikes that match times in spike_times cluster_ids : find all spikes from a given cluster. Often, you would also specify 'num_waveforms' to cap the total number of waveforms per cluster via random sample, unless you want every spike for those clusters By default, waveforms will be extracted for every channel on the probe, unless you request specific channel_ids_by_cluster as a nClusters x nChannels matrix, or specify best_n_channels which will pick the best channels separately for each cluster. snippetSet = ks . getWaveformsFromRawData ( 'cluster_ids' , cluster_id , ... 'num_waveforms' , 50 , 'best_n_channels' , 20 , 'car' , true ); snippetSet . plotAtProbeLocations ( 'alpha' , 0.8 ); As you can see, there are other waveforms in the background corrupting these extracted waveforms. We can use the other Kilosort detected spike times and their respective templates to automatically clean these waveforms by subtracting the appropriate template at the appropriate times. snippetSet = ks . getWaveformsFromRawData ( 'cluster_ids' , cluster_id , ... 'num_waveforms' , 50 , 'best_n_channels' , 20 , 'car' , true , ... 'subtractOtherClusters' , true ); snippetSet . plotAtProbeLocations ( 'alpha' , 0.8 );","title":"Extracting waveforms via KilosortDataset"},{"location":"waveforms.html#extracting-waveforms-via-kilosorttrialsegmenteddataset","text":"If you have already segmented the data into trials , you might wish to extract these waveforms for specific trials or even specific time windows within a trial, e.g. to check for behaviorally-triggered probe movement. For example, this will extract all spikes that occurred in the first 50 ms of each trial: cluster_ind = seg . lookup_clusterIds ( cluster_id ); mask_by_trial = cell ( seg . nTrials , 1 ); for iTrial = 1 : seg . nTrials mask_by_trial { iTrial } = seg . spike_times_ms_rel_start { iTrial , cluster_ind } < 50 ; end snippetSet = seg . getWaveformsFromRawData ( 'mask_cell' , mask_by_trial , 'cluster_id' , cluster_id , ... 'best_n_channels' , 20 , 'subtractOtherClusters' , true );","title":"Extracting waveforms via KilosortTrialSegmentedDataset"},{"location":"publish/md/ex01_walkthrough.html","text":"Example 1: Walkthrough \u00b6 Data setup \u00b6 homeDir = string ( java . lang . System . getProperty ( 'user.home' )); exDataDir = homeDir + 'work/npxutils/example-data' ; ksDataDir = homeDir + 'work/npxutils/kilosort' ; Create ImecDataset \u00b6 Create an ImecDataset from a specified raw data file and probe name: channelMapFile = 'neuropixPhase3A_kilosortChanMap.mat' ; apBinFile = exDataDir + '/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.ap.bin' ; imec = Neuropixel . ImecDataset ( apBinFile , 'channelMap' , channelMapFile ); disp ( imec ) Preprocess it a bit: % Mark individual channels as bad based on RMS voltage rmsBadChannels = imec . markBadChannelsByRMS ( 'rmsRange' , [ 3 100 ]); % Specify names for the individual bits in the sync channel imec . setSyncBitNames ([ 1 2 3 ], { 'trialInfo' , 'trialStart' , 'stim' }); % Save the bad channels and Sync bit names to the .imec.ap.meta file so they are loaded next time imec . writeModifiedAPMeta (); Common average referencing: % Perform common average referencing on the file and save the results % to a separate \"cleaned\" directory cleanedDir = exDataDir + '/cleaned_datasets' ; cleanedApBinFile = cleanedDir + 'Vinnie_20180817_All_cleaned.imec.ap.bin' ; extraMeta = struct (); extraMeta . commonAverageReferenced = true ; fnList = {@ npxutils . dataprocess . commonAverageReference }; imec = imec . saveTransformedDataset ( cleanedApBinFile , 'transformAP' , fnList , 'extraMeta' , extraMeta ); Get it ready for sending to Kilosort: % Symlink the cleaned dataset into a separate directory for Kilosort2 ksPath = ksDataDir + '/Vinnie_20180817_All_cleaned.imec.ap.bin' ; imec = imec . symLinkAPIntoDirectory ( ksPath ); Visual inspection \u00b6 % Inspect the raw IMEC traces imec . inspectAP_timeWindow ([ 200 201 ]); % 200-201 seconds into the recording Kilosort time! \u00b6 % Run Kilosort2 npxutils . runKilosort2 ( imec ); % Load the Kilosort2 results ks = npxutils . KilosortDataset (); ks . load () % Define how the data are segmented into trials % (You must implement this function yourself) % tsi = computeTrialSegmentation(imec) % TODO: Figure out how to implement a trial segmentation function for these % examples so the Live Script can run through. % Segment the KilosortDataset into trials based on start and stop idx. % trial_ids are specified according to the data structure being merged into. % If a trial is included in trial_ids but not found in tsi, % its contents would be blank and trial_has_data(i) would be set false. % % Each of seg's properties are now nTrials x ... cells containing the data % corresponding to that trial trial_ids = min ( tsi . trialId ): max ( tsi . trialId ); seg = npxutils . KilosortTrialSegmentedDataset ( ks , tsi , trial_ids ); disp ( seg ) % Compute useful stats about each template and cluster metrics = ks . getMetrics () % Plot a drift map, annotated with trial start markers metrics . plotDriftmap ( 'tsi' , tsi ); Note that the cluster structure looks distinct during a few time windows near the beginning and end of the recording, corresponding to regions when no trials were being performed (blue ticks near the bottom). % Extract raw waveforms for a specific cluster id at the 24 largest amplitude channels % Clean these waveforms by subtracting the contribution of other clusters spiking within the same time window ss = ks . getWaveformsFromRawData ( 'cluster_id' , 255 , 'num_waveforms' , 100 , ... 'best_n_channels' , 24 , 'subtractOtherClusters' , true ) % Plot these waveforms at their physical coordinates on the neuropixel ss . plotAtProbeLocations ()","title":"Ex 01: Walkthrough (Markdown)"},{"location":"publish/md/ex01_walkthrough.html#example-1-walkthrough","text":"","title":"Example 1: Walkthrough"},{"location":"publish/md/ex01_walkthrough.html#data-setup","text":"homeDir = string ( java . lang . System . getProperty ( 'user.home' )); exDataDir = homeDir + 'work/npxutils/example-data' ; ksDataDir = homeDir + 'work/npxutils/kilosort' ;","title":"Data setup"},{"location":"publish/md/ex01_walkthrough.html#create-imecdataset","text":"Create an ImecDataset from a specified raw data file and probe name: channelMapFile = 'neuropixPhase3A_kilosortChanMap.mat' ; apBinFile = exDataDir + '/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.ap.bin' ; imec = Neuropixel . ImecDataset ( apBinFile , 'channelMap' , channelMapFile ); disp ( imec ) Preprocess it a bit: % Mark individual channels as bad based on RMS voltage rmsBadChannels = imec . markBadChannelsByRMS ( 'rmsRange' , [ 3 100 ]); % Specify names for the individual bits in the sync channel imec . setSyncBitNames ([ 1 2 3 ], { 'trialInfo' , 'trialStart' , 'stim' }); % Save the bad channels and Sync bit names to the .imec.ap.meta file so they are loaded next time imec . writeModifiedAPMeta (); Common average referencing: % Perform common average referencing on the file and save the results % to a separate \"cleaned\" directory cleanedDir = exDataDir + '/cleaned_datasets' ; cleanedApBinFile = cleanedDir + 'Vinnie_20180817_All_cleaned.imec.ap.bin' ; extraMeta = struct (); extraMeta . commonAverageReferenced = true ; fnList = {@ npxutils . dataprocess . commonAverageReference }; imec = imec . saveTransformedDataset ( cleanedApBinFile , 'transformAP' , fnList , 'extraMeta' , extraMeta ); Get it ready for sending to Kilosort: % Symlink the cleaned dataset into a separate directory for Kilosort2 ksPath = ksDataDir + '/Vinnie_20180817_All_cleaned.imec.ap.bin' ; imec = imec . symLinkAPIntoDirectory ( ksPath );","title":"Create ImecDataset"},{"location":"publish/md/ex01_walkthrough.html#visual-inspection","text":"% Inspect the raw IMEC traces imec . inspectAP_timeWindow ([ 200 201 ]); % 200-201 seconds into the recording","title":"Visual inspection"},{"location":"publish/md/ex01_walkthrough.html#kilosort-time","text":"% Run Kilosort2 npxutils . runKilosort2 ( imec ); % Load the Kilosort2 results ks = npxutils . KilosortDataset (); ks . load () % Define how the data are segmented into trials % (You must implement this function yourself) % tsi = computeTrialSegmentation(imec) % TODO: Figure out how to implement a trial segmentation function for these % examples so the Live Script can run through. % Segment the KilosortDataset into trials based on start and stop idx. % trial_ids are specified according to the data structure being merged into. % If a trial is included in trial_ids but not found in tsi, % its contents would be blank and trial_has_data(i) would be set false. % % Each of seg's properties are now nTrials x ... cells containing the data % corresponding to that trial trial_ids = min ( tsi . trialId ): max ( tsi . trialId ); seg = npxutils . KilosortTrialSegmentedDataset ( ks , tsi , trial_ids ); disp ( seg ) % Compute useful stats about each template and cluster metrics = ks . getMetrics () % Plot a drift map, annotated with trial start markers metrics . plotDriftmap ( 'tsi' , tsi ); Note that the cluster structure looks distinct during a few time windows near the beginning and end of the recording, corresponding to regions when no trials were being performed (blue ticks near the bottom). % Extract raw waveforms for a specific cluster id at the 24 largest amplitude channels % Clean these waveforms by subtracting the contribution of other clusters spiking within the same time window ss = ks . getWaveformsFromRawData ( 'cluster_id' , 255 , 'num_waveforms' , 100 , ... 'best_n_channels' , 24 , 'subtractOtherClusters' , true ) % Plot these waveforms at their physical coordinates on the neuropixel ss . plotAtProbeLocations ()","title":"Kilosort time!"},{"location":"publish/md/ex02_imecdataset.html","text":"About ImecDataset \u00b6 The npxutils.ImecDataset class wraps one individual recording session acquired with SpikeGLX. Currently, four files with extensions .imec.ap.bin , .imec.ap.meta , .imec.lf.bin , and .imec.lf.meta comprise one ImecDataset. Data setup \u00b6 homeDir = string ( java . lang . System . getProperty ( 'user.home' )); exDataDir = homeDir + 'work/npxutils/example-data' ; Constructing an ImecDataset \u00b6 You construct a npxutils.ImecDataset by pointing it at the path to your dataset. How you specify the path is flexible. You can point directly at one of the files: imec = npxutils . ImecDataset ( exDataDir + '/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin' ); Error using npxutils.ImecDataset (line 173) No AP or LF Imec file found at or in /Users/jankework/npxutils/example-data/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin Or specify the common prefix to the .imec. * files comprising the dataset: imecB = npxutils . ImecDataset ( exDataDir + '/raw_datasets/neuropixel_01_g0_t0' ); The common prefix can be shorter as long as there is no ambiguity: imecC = npxutils . ImecDataset ( exDataDir + '/raw_datasets/neuropixel_01' ); You can also point at the parent directory as long as only one .ap.bin file is contained within: imecD = npxutils . ImecDataset ( exDataDir + '/data/raw_datasets/' ); These are all equivalent, in that the resulting imec instance will wrap both AP and LF bin and meta files. (Though it\u2019s okay if the LF files are missing). Specifying a Channel Map \u00b6 When constructing the ImecDataset, you can specify a channel map. If you don\u2019t specify one, the default will be returned by npxutils.util.getDefaultChannelMapFile() , which in turn will look for the file pointed to by the environment variables 'NEUROPIXEL_MAP_FILE' or 'NPIX_MAP_FILE' . You can set these using Matlab\u2019s setenv function. These .mat files are expected to be in the same format as found on the neuropixels repo . For the phase 3A probe with 384 channels, the file neuropixPhase3A_kilosortChanMap.mat contains: ld = load ( 'neuropixPhase3A_kilosortChanMap.mat' ) You can construct a ChannelMap directly by pointing at the .mat file, although every function within neuropixel-utils will also accept the filename and construct the ChannelMap for you: probeName = 'neuropixPhase3B1' ; probeMatFilePath = npxutils . globals . distroot + '/map_files/' + probeName + '_kilosortChanMap.mat' ; chanMapObject = npxutils . ChannelMap ( probeMatFilePath ) Then you can use this map for an ImecDataset using either of the following: imecE = npxutils . ImecDataset ( 'channelMap' , chanMapObject ); imecF = npxutils . ImecDataset ( 'channelMap' , probeMatFilePath ); Exploring metadata \u00b6 When the ImecDataset is created, the metadata are loaded from the .ap.meta file. You can request the full metadata using: meta = imec . readAPMeta () The most commonly accessed metadata is stored in properties of the ImecDataset: disp ( imec ) Setting sync bit names \u00b6 For convenience, if you use the sync bits for individual TTL signals during your recordings, you can set their names for the recording so that subsequent processing can refer to the bits by name rather than index. You may also find it useful to store additional data in some sync bits during subsequent processing, such as marking regions of time where an artifact was detected, such that specifying the bit by name is useful. Bits are ordered like bitget , i.e. 1 is the least significant bit. imec . setSyncBitNames ( 1 , \"trialStart\" ); The full set of sync bits is found in imec.syncBitNames , or you can lookup the bit corresponding to a given name using: idx = imec . lookupSyncBitByName ( \"trialStart\" ); Marking bad channels \u00b6 You can manually mark specific channels as bad using the markBadChannels function and passing a list of IDs to it: channelIds = [ 17 23 52 ]; imec . markBadChannels ( channelIds ); WARNING: Use channel IDs, not indices \u00b6 Note that like all channel lists, channelIds is specified using the actual unique ids of each channel (as specified in the ChannelMap), which is not necessarily their index into the channel map if the channels are not contiguously numbered. You can use lookup_channelIds to find the channel indices for a given set of channel ids if needed: [ channelInds , channelIds ] = imec . lookup_channelIds ( channelIds ) One common task is marking channels as bad if their RMS voltage lies outside a reasonable range: goodRmsRange = [ 3 100 ]; % [low high] range of RMS in uV imec . markBadChannelsByRMS ( 'rmsRange' , goodRmsRange ); The remaining \u201cgood\u201d channel ids can always be accessed using imec.goodChannels which will be the set of connected channels excluding the bad channels. Writing modified metadata back to disk \u00b6 After making any modifications to the metadata, such as setting the sync bit names or marking bad channels, you can write it back to disk (in the .imec.ap.meta file) such that it will be reloaded automatically the next time you create an ImecDataset instance for that file. imec . writeModifiedAPMeta (); You can also append whatever fields you want to the meta file using the extraMeta parameter: extraMeta . cleaned = true ; extraMeta . cleaningAlgorithm = 'v1' ; imec . writeModifiedAPMeta ( 'extraMeta' , extraMeta ); Accessing data \u00b6 Raw memory maps \u00b6 The most convenient way to access the data is to request a memory map: mmap = imec . memmapAP_full (); value = mmap . Data . x ( ch_index , sample_index ) % access a specific sample Equivalent functionality is available for LF files using imec.memmapLF_full() . If you wish to modify the underlying data file directly, you can also request a Writeable version of the memory map: mmap = imec . memmapAP_full ( 'Writiable' , true ); mmap . Data . x ( ch_index , sample_index ) = new_value ; % overwrite a specific sample Reading specific time window \u00b6 You can also request a specific sample or time window directly: idxWindow = [ idxFirst idxLast ]; [ partialData , sampleIdx ] = imec . readAP_idx ( idxWindow ); timeWindow = [ secStart , secStop ]; % in seconds [ partialDataB , sampleIdxB ] = imec . readAP_timeWindow ( timeWindow ); Plotting specific time windows \u00b6 You can also quickly generate a stacked traces plot of a specific time window, optionally selecting which channels to plot. Take care to select a reasonable time window to avoid overwhelming your system. All channels are individually centered and then collectively normalized by the maximum value before plotting. You can change the global scaling factor by specifying gain > 1. imec``.``inspectAP_idxWindow``(``idxWindow``,`` ``...``) imec``.``inspectAP_timeWindow``(``timeWindow``,`` ``...``) There are additional optional parameters you can specify: channels : channel indices to plot, defaults to imec.mappedChannels syncBits : which sync bits to plot individually, defaults to imec.syncBitsNamed gain : global scaling factor, values larger then 1 will magnify the individual channels, defaults to 0.95 car : perform common average referencing before plotting, defaults to false downsample : take every nth sample to speed up plotting, defaults to 1 Good channels are plotted in black, non-connected channels in blue, and bad channels in red. Sync bits are also shown in red and are not affected by the normalization gain. % TODO: Some code that actually generates a plot here! Reading sync channel \u00b6 You can access the sync channel all at once using: sync = imec . readSync (); trialStartBit = imec . readSyncBit ( \"trialStart\" ); Or a specific sample or time window using: [ partialSync , sampleIdx ] = imec . readSync_idx ( idxWindow ); [ partialSyncB , sampleIdxB ] = imec . readSync_timeWindow ( timeWindow ); You can also access the logical values of specific bits either by bit index or name using: partial = imec . readSyncBits_idx ( bits_or_names , idxWindow ); % nTime x nBits trialStart_partial = imec . readSyncBits_idx ( \"trialStart\" , idxWindow ); % nTime x 1 Building a preprocessing pipeline \u00b6 If the raw .imec.ap.bin file must be processed in some way before running Kilosort, e.g. to remove artifacts, you can implement this efficiently by writing a transformation function that will act on chunks of the data. One example is found in Neuropixel.DataProcessFn.commonAverageReference : function [data, extra] = commonAverageReference ( imec, data, chIds, sampleIdx ) %#ok<INUSD> % chIds are the channel ids and imec.goodChannels is a list of channel ids % so this will lookup the channel indices of those channels both in chIdx that % are also marked as good. This prevents us from computing the reference % from the sync, reference, or bad channels. chanMask = imec . lookup_channelIds ( intersect ( chIds , imec . goodChannels )); % subtract median of each channel over time data ( chanMask , :) = bsxfun (@ minus , data ( chanMask , :), median ( data ( chanMask , :), 2 )); % subtract median across good channels data ( chanMask , :) = bsxfun (@ minus , data ( chanMask , :), median ( data ( chanMask , :), 1 )); end Essentially, your transform function can perform any modifications to the data matrix and return the resulting data matrix. Here, imec will be the ImecDataset being transformed, data will be the nChannels x nTime chunk of data being processed. chIds will be the channel ids (not necessarily their indices into data but the ids assigned by the channel map), and will typically be the full list of channel ids present in the data file. sampleIdx is the sample indices in the current chunk. extra is an optional output argument that allows you to store any additional metadata. After the transformation function has been run on every chunk of the dataset, these individual extra outputs will be accumulated in a cell array by chunk. Modifying a dataset during copy to new location \u00b6 Once you\u2019ve written your transform function (or functions), you can run them on the dataset using: imecOut = imec . saveTransformedDataset ( outPath , 'transformAP' , ... \\ { cell of function handles }, 'transformLF' , { cell of function handles }); Here, outPath should include the folder where the new datasets should be written. By default, the file stem (preceeding .ap.bin ) will match the leaf directory in outPath , but this can be specified manually by passing a stem parameter: imecOut = imec . saveTransformedDataset ( '/path/to/datasets' , 'stem' , 'modifiedDataset' , ... ) % creates /path/to/datasets/modifiedDataset.ap.bin, .ap.meta, etc. You can provide one or more function handles (e.g. @Neuropixel.DataProcessFn.commonAverageReference ) that will be applied sequentially. Other optional parameters include: dryRun : if true, no actual data will be modified on disk, facilitating testing or step by step debugging of the transform functions before writing data. (default false) gpuArray : if true, the data chunks will be copied to the GPU and the transformation functions will receive and return GPU arrays applyScaling : if true, the data will be converted to floating point values with the correct analog scale. if false (default) the data will remain in the original, unscaled int16 quantization. writeAP : if true, the AP file will be transformed and copied writeLF : if true, the LF file will be transformed and copied (default false but will be set true automatically if any transformLF is non-empty) goodChannelsOnly : send only the channels marked good to the transform function connectedChannelsOnly : send only the connected channels to the transform function mappedChannelsOnly : send only the mapped channels to the transform function chunkSize : specify the number of time samples sent to transform functions at once extraMeta : a struct with extra meta fields to include or overwrite with the output file timeShifts : a Neuropixel.TimeShiftSpec instance used to excise time windows, see excising time windows WARNING: Save transformed data to a new folder! \u00b6 Ensure that outPath refers to separate directory so that you make a copy of the dataset rather than writing over the same location. An error will be thrown if any existing files would be overwritten by this call. Modifying a dataset in place \u00b6 Rather than generate a copy, you can also modify a file in place if you\u2019re short on disk space, but be careful, as there\u2019s no undo if anything goes wrong. The same additional parameters are accepted, and you may wish to test your code first by passing 'dryRun', true . imec . modifyAPInPlace ( outPath , { cell of function handles }, ... ); imec . modifyLFInPlace ( outPath , { cell of function handles }, ... ); Concatenating multiple files together \u00b6 If you have multiple separate recording files that you wish to process and sort together, you can concatenate them together during the copy. The code will also scale the datasets up to a common gain factor if the file gains differ from each other. This will not of course increase the resolution of low-gain files, but it will ensure that the signal amplitudes match across files with different gains. imecList = { imec1 , imec2 , ... }; imecOut = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( imecList , outPath , ... 'transformAP' , { cell of function handles }, ... 'transformLF' , { cell of function handles }, ... ); Making copies and symbolic links \u00b6 You can generate a copy of a dataset using: [ imecOut ] = imec . saveTransformedDataset ( outPath , 'writeAP' , true , 'writeLF' , true ); Alternatively, you can create symbolic links to the AP bin and meta files in a new location using: imecLinked = imec . symLinkAPIntoDirectory ( outPath ); This is useful for running Kilosort with varying parameters, since each run would ideally live in its own directory but there\u2019s no need for a real copy of the raw data. Excising time windows \u00b6 Occasionally it can be beneficial to remove certain time windows from a file, or to omit them while plotting data. This may be accomplished using npxutils.TimeShiftSpec instances to indicate which windows of time to keep and how to shift them so as to remove gaps. A TimeShiftSpec specifies a list of sample intervals bounded by a start and stop index in properties idxStart and idxStop . The start index in idxStart will be shifted to lie at sample index idxShiftStart . You can calculate these shifts directly, but it is typically easier to specify only the sample intervals you wish to keep and then construct the TimeShiftSpec using: timeShifts = npxutils . TimeShiftSpec . buildToExciseGaps ( idxStartList , idxStopList ); If you have known trial boundaries in your file (see Segmenting a Kilosort dataset into trials for more information), you can also excise the regions of time far from trial boundaries using the TrialSegmentationInfo instance. I\u2019ve found this to be useful to exclude time windows where the subject was asleep from further analysis. timeShifts = tsi . computeShiftsExciseRegionsOutsideTrials ( 'maxPauseSec' , 20 ); You can then pass along this npxutils.TimeShiftSpec to any of the data transform functions. Depending on whether the timeShifts object was created in indices of AP band sample rate or LF band sample rate, you should pass it along as timeShiftsAP or timeShiftsLF . The conversion to the other sampling rate will be handled automatically so that the excision is performed on both datasets appropriately. imecOut = imec . saveTransformedDataset ( outPath , 'timeShiftsAP' , timeShifts , ... ); A cell array of npxutils.TimeShiftSpec instances can be provided when concatenating multiple files: imecOut = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( outPath , imecList , ... 'timeShiftsAP' , { timeShift1 , timeShift2 , ... }, ...); Referring to Source Datasets \u00b6 If helpful, when loading a derived ImecDataset , you can specify the sourceDatasets parameter to provide an array of ImecDataset instances corresponding to the original, pre-processed source datasets. Here, this would be the set of raw datasets provided as the imecList argument above. For certain methods, you can then pass parameter fromSourceDatasets , true and the corresponding window of time from the source datasets will be plotted instead of the processed data. This will automatically handle any time shifts and excisions performed; consequently it is helpful for debugging processing pipelines to see the before and after data. imecProcessed = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( outPath , imecList ); % ... or: imecProcessedB = npxutils . ImecDataset ( outPath , 'sourceDatasets' , { imecRaw1 , imecRaw2 }); imecProcessed . inspectAP_timeWindow ([ 1 2 ], 'fromSourceDatasets' , true );","title":"Ex 02: ImecDatasets (Markdown)"},{"location":"publish/md/ex02_imecdataset.html#about-imecdataset","text":"The npxutils.ImecDataset class wraps one individual recording session acquired with SpikeGLX. Currently, four files with extensions .imec.ap.bin , .imec.ap.meta , .imec.lf.bin , and .imec.lf.meta comprise one ImecDataset.","title":"About ImecDataset"},{"location":"publish/md/ex02_imecdataset.html#data-setup","text":"homeDir = string ( java . lang . System . getProperty ( 'user.home' )); exDataDir = homeDir + 'work/npxutils/example-data' ;","title":"Data setup"},{"location":"publish/md/ex02_imecdataset.html#constructing-an-imecdataset","text":"You construct a npxutils.ImecDataset by pointing it at the path to your dataset. How you specify the path is flexible. You can point directly at one of the files: imec = npxutils . ImecDataset ( exDataDir + '/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin' ); Error using npxutils.ImecDataset (line 173) No AP or LF Imec file found at or in /Users/jankework/npxutils/example-data/raw_datasets/neuropixel_01_g0_t0.imec.ap.bin Or specify the common prefix to the .imec. * files comprising the dataset: imecB = npxutils . ImecDataset ( exDataDir + '/raw_datasets/neuropixel_01_g0_t0' ); The common prefix can be shorter as long as there is no ambiguity: imecC = npxutils . ImecDataset ( exDataDir + '/raw_datasets/neuropixel_01' ); You can also point at the parent directory as long as only one .ap.bin file is contained within: imecD = npxutils . ImecDataset ( exDataDir + '/data/raw_datasets/' ); These are all equivalent, in that the resulting imec instance will wrap both AP and LF bin and meta files. (Though it\u2019s okay if the LF files are missing).","title":"Constructing an ImecDataset"},{"location":"publish/md/ex02_imecdataset.html#specifying-a-channel-map","text":"When constructing the ImecDataset, you can specify a channel map. If you don\u2019t specify one, the default will be returned by npxutils.util.getDefaultChannelMapFile() , which in turn will look for the file pointed to by the environment variables 'NEUROPIXEL_MAP_FILE' or 'NPIX_MAP_FILE' . You can set these using Matlab\u2019s setenv function. These .mat files are expected to be in the same format as found on the neuropixels repo . For the phase 3A probe with 384 channels, the file neuropixPhase3A_kilosortChanMap.mat contains: ld = load ( 'neuropixPhase3A_kilosortChanMap.mat' ) You can construct a ChannelMap directly by pointing at the .mat file, although every function within neuropixel-utils will also accept the filename and construct the ChannelMap for you: probeName = 'neuropixPhase3B1' ; probeMatFilePath = npxutils . globals . distroot + '/map_files/' + probeName + '_kilosortChanMap.mat' ; chanMapObject = npxutils . ChannelMap ( probeMatFilePath ) Then you can use this map for an ImecDataset using either of the following: imecE = npxutils . ImecDataset ( 'channelMap' , chanMapObject ); imecF = npxutils . ImecDataset ( 'channelMap' , probeMatFilePath );","title":"Specifying a Channel Map"},{"location":"publish/md/ex02_imecdataset.html#exploring-metadata","text":"When the ImecDataset is created, the metadata are loaded from the .ap.meta file. You can request the full metadata using: meta = imec . readAPMeta () The most commonly accessed metadata is stored in properties of the ImecDataset: disp ( imec )","title":"Exploring metadata"},{"location":"publish/md/ex02_imecdataset.html#setting-sync-bit-names","text":"For convenience, if you use the sync bits for individual TTL signals during your recordings, you can set their names for the recording so that subsequent processing can refer to the bits by name rather than index. You may also find it useful to store additional data in some sync bits during subsequent processing, such as marking regions of time where an artifact was detected, such that specifying the bit by name is useful. Bits are ordered like bitget , i.e. 1 is the least significant bit. imec . setSyncBitNames ( 1 , \"trialStart\" ); The full set of sync bits is found in imec.syncBitNames , or you can lookup the bit corresponding to a given name using: idx = imec . lookupSyncBitByName ( \"trialStart\" );","title":"Setting sync bit names"},{"location":"publish/md/ex02_imecdataset.html#marking-bad-channels","text":"You can manually mark specific channels as bad using the markBadChannels function and passing a list of IDs to it: channelIds = [ 17 23 52 ]; imec . markBadChannels ( channelIds );","title":"Marking bad channels"},{"location":"publish/md/ex02_imecdataset.html#warning-use-channel-ids-not-indices","text":"Note that like all channel lists, channelIds is specified using the actual unique ids of each channel (as specified in the ChannelMap), which is not necessarily their index into the channel map if the channels are not contiguously numbered. You can use lookup_channelIds to find the channel indices for a given set of channel ids if needed: [ channelInds , channelIds ] = imec . lookup_channelIds ( channelIds ) One common task is marking channels as bad if their RMS voltage lies outside a reasonable range: goodRmsRange = [ 3 100 ]; % [low high] range of RMS in uV imec . markBadChannelsByRMS ( 'rmsRange' , goodRmsRange ); The remaining \u201cgood\u201d channel ids can always be accessed using imec.goodChannels which will be the set of connected channels excluding the bad channels.","title":"WARNING: Use channel IDs, not indices"},{"location":"publish/md/ex02_imecdataset.html#writing-modified-metadata-back-to-disk","text":"After making any modifications to the metadata, such as setting the sync bit names or marking bad channels, you can write it back to disk (in the .imec.ap.meta file) such that it will be reloaded automatically the next time you create an ImecDataset instance for that file. imec . writeModifiedAPMeta (); You can also append whatever fields you want to the meta file using the extraMeta parameter: extraMeta . cleaned = true ; extraMeta . cleaningAlgorithm = 'v1' ; imec . writeModifiedAPMeta ( 'extraMeta' , extraMeta );","title":"Writing modified metadata back to disk"},{"location":"publish/md/ex02_imecdataset.html#accessing-data","text":"","title":"Accessing data"},{"location":"publish/md/ex02_imecdataset.html#raw-memory-maps","text":"The most convenient way to access the data is to request a memory map: mmap = imec . memmapAP_full (); value = mmap . Data . x ( ch_index , sample_index ) % access a specific sample Equivalent functionality is available for LF files using imec.memmapLF_full() . If you wish to modify the underlying data file directly, you can also request a Writeable version of the memory map: mmap = imec . memmapAP_full ( 'Writiable' , true ); mmap . Data . x ( ch_index , sample_index ) = new_value ; % overwrite a specific sample","title":"Raw memory maps"},{"location":"publish/md/ex02_imecdataset.html#reading-specific-time-window","text":"You can also request a specific sample or time window directly: idxWindow = [ idxFirst idxLast ]; [ partialData , sampleIdx ] = imec . readAP_idx ( idxWindow ); timeWindow = [ secStart , secStop ]; % in seconds [ partialDataB , sampleIdxB ] = imec . readAP_timeWindow ( timeWindow );","title":"Reading specific time window"},{"location":"publish/md/ex02_imecdataset.html#plotting-specific-time-windows","text":"You can also quickly generate a stacked traces plot of a specific time window, optionally selecting which channels to plot. Take care to select a reasonable time window to avoid overwhelming your system. All channels are individually centered and then collectively normalized by the maximum value before plotting. You can change the global scaling factor by specifying gain > 1. imec``.``inspectAP_idxWindow``(``idxWindow``,`` ``...``) imec``.``inspectAP_timeWindow``(``timeWindow``,`` ``...``) There are additional optional parameters you can specify: channels : channel indices to plot, defaults to imec.mappedChannels syncBits : which sync bits to plot individually, defaults to imec.syncBitsNamed gain : global scaling factor, values larger then 1 will magnify the individual channels, defaults to 0.95 car : perform common average referencing before plotting, defaults to false downsample : take every nth sample to speed up plotting, defaults to 1 Good channels are plotted in black, non-connected channels in blue, and bad channels in red. Sync bits are also shown in red and are not affected by the normalization gain. % TODO: Some code that actually generates a plot here!","title":"Plotting specific time windows"},{"location":"publish/md/ex02_imecdataset.html#reading-sync-channel","text":"You can access the sync channel all at once using: sync = imec . readSync (); trialStartBit = imec . readSyncBit ( \"trialStart\" ); Or a specific sample or time window using: [ partialSync , sampleIdx ] = imec . readSync_idx ( idxWindow ); [ partialSyncB , sampleIdxB ] = imec . readSync_timeWindow ( timeWindow ); You can also access the logical values of specific bits either by bit index or name using: partial = imec . readSyncBits_idx ( bits_or_names , idxWindow ); % nTime x nBits trialStart_partial = imec . readSyncBits_idx ( \"trialStart\" , idxWindow ); % nTime x 1","title":"Reading sync channel"},{"location":"publish/md/ex02_imecdataset.html#building-a-preprocessing-pipeline","text":"If the raw .imec.ap.bin file must be processed in some way before running Kilosort, e.g. to remove artifacts, you can implement this efficiently by writing a transformation function that will act on chunks of the data. One example is found in Neuropixel.DataProcessFn.commonAverageReference : function [data, extra] = commonAverageReference ( imec, data, chIds, sampleIdx ) %#ok<INUSD> % chIds are the channel ids and imec.goodChannels is a list of channel ids % so this will lookup the channel indices of those channels both in chIdx that % are also marked as good. This prevents us from computing the reference % from the sync, reference, or bad channels. chanMask = imec . lookup_channelIds ( intersect ( chIds , imec . goodChannels )); % subtract median of each channel over time data ( chanMask , :) = bsxfun (@ minus , data ( chanMask , :), median ( data ( chanMask , :), 2 )); % subtract median across good channels data ( chanMask , :) = bsxfun (@ minus , data ( chanMask , :), median ( data ( chanMask , :), 1 )); end Essentially, your transform function can perform any modifications to the data matrix and return the resulting data matrix. Here, imec will be the ImecDataset being transformed, data will be the nChannels x nTime chunk of data being processed. chIds will be the channel ids (not necessarily their indices into data but the ids assigned by the channel map), and will typically be the full list of channel ids present in the data file. sampleIdx is the sample indices in the current chunk. extra is an optional output argument that allows you to store any additional metadata. After the transformation function has been run on every chunk of the dataset, these individual extra outputs will be accumulated in a cell array by chunk.","title":"Building a preprocessing pipeline"},{"location":"publish/md/ex02_imecdataset.html#modifying-a-dataset-during-copy-to-new-location","text":"Once you\u2019ve written your transform function (or functions), you can run them on the dataset using: imecOut = imec . saveTransformedDataset ( outPath , 'transformAP' , ... \\ { cell of function handles }, 'transformLF' , { cell of function handles }); Here, outPath should include the folder where the new datasets should be written. By default, the file stem (preceeding .ap.bin ) will match the leaf directory in outPath , but this can be specified manually by passing a stem parameter: imecOut = imec . saveTransformedDataset ( '/path/to/datasets' , 'stem' , 'modifiedDataset' , ... ) % creates /path/to/datasets/modifiedDataset.ap.bin, .ap.meta, etc. You can provide one or more function handles (e.g. @Neuropixel.DataProcessFn.commonAverageReference ) that will be applied sequentially. Other optional parameters include: dryRun : if true, no actual data will be modified on disk, facilitating testing or step by step debugging of the transform functions before writing data. (default false) gpuArray : if true, the data chunks will be copied to the GPU and the transformation functions will receive and return GPU arrays applyScaling : if true, the data will be converted to floating point values with the correct analog scale. if false (default) the data will remain in the original, unscaled int16 quantization. writeAP : if true, the AP file will be transformed and copied writeLF : if true, the LF file will be transformed and copied (default false but will be set true automatically if any transformLF is non-empty) goodChannelsOnly : send only the channels marked good to the transform function connectedChannelsOnly : send only the connected channels to the transform function mappedChannelsOnly : send only the mapped channels to the transform function chunkSize : specify the number of time samples sent to transform functions at once extraMeta : a struct with extra meta fields to include or overwrite with the output file timeShifts : a Neuropixel.TimeShiftSpec instance used to excise time windows, see excising time windows","title":"Modifying a dataset during copy to new location"},{"location":"publish/md/ex02_imecdataset.html#warning-save-transformed-data-to-a-new-folder","text":"Ensure that outPath refers to separate directory so that you make a copy of the dataset rather than writing over the same location. An error will be thrown if any existing files would be overwritten by this call.","title":"WARNING: Save transformed data to a new folder!"},{"location":"publish/md/ex02_imecdataset.html#modifying-a-dataset-in-place","text":"Rather than generate a copy, you can also modify a file in place if you\u2019re short on disk space, but be careful, as there\u2019s no undo if anything goes wrong. The same additional parameters are accepted, and you may wish to test your code first by passing 'dryRun', true . imec . modifyAPInPlace ( outPath , { cell of function handles }, ... ); imec . modifyLFInPlace ( outPath , { cell of function handles }, ... );","title":"Modifying a dataset in place"},{"location":"publish/md/ex02_imecdataset.html#concatenating-multiple-files-together","text":"If you have multiple separate recording files that you wish to process and sort together, you can concatenate them together during the copy. The code will also scale the datasets up to a common gain factor if the file gains differ from each other. This will not of course increase the resolution of low-gain files, but it will ensure that the signal amplitudes match across files with different gains. imecList = { imec1 , imec2 , ... }; imecOut = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( imecList , outPath , ... 'transformAP' , { cell of function handles }, ... 'transformLF' , { cell of function handles }, ... );","title":"Concatenating multiple files together"},{"location":"publish/md/ex02_imecdataset.html#making-copies-and-symbolic-links","text":"You can generate a copy of a dataset using: [ imecOut ] = imec . saveTransformedDataset ( outPath , 'writeAP' , true , 'writeLF' , true ); Alternatively, you can create symbolic links to the AP bin and meta files in a new location using: imecLinked = imec . symLinkAPIntoDirectory ( outPath ); This is useful for running Kilosort with varying parameters, since each run would ideally live in its own directory but there\u2019s no need for a real copy of the raw data.","title":"Making copies and symbolic links"},{"location":"publish/md/ex02_imecdataset.html#excising-time-windows","text":"Occasionally it can be beneficial to remove certain time windows from a file, or to omit them while plotting data. This may be accomplished using npxutils.TimeShiftSpec instances to indicate which windows of time to keep and how to shift them so as to remove gaps. A TimeShiftSpec specifies a list of sample intervals bounded by a start and stop index in properties idxStart and idxStop . The start index in idxStart will be shifted to lie at sample index idxShiftStart . You can calculate these shifts directly, but it is typically easier to specify only the sample intervals you wish to keep and then construct the TimeShiftSpec using: timeShifts = npxutils . TimeShiftSpec . buildToExciseGaps ( idxStartList , idxStopList ); If you have known trial boundaries in your file (see Segmenting a Kilosort dataset into trials for more information), you can also excise the regions of time far from trial boundaries using the TrialSegmentationInfo instance. I\u2019ve found this to be useful to exclude time windows where the subject was asleep from further analysis. timeShifts = tsi . computeShiftsExciseRegionsOutsideTrials ( 'maxPauseSec' , 20 ); You can then pass along this npxutils.TimeShiftSpec to any of the data transform functions. Depending on whether the timeShifts object was created in indices of AP band sample rate or LF band sample rate, you should pass it along as timeShiftsAP or timeShiftsLF . The conversion to the other sampling rate will be handled automatically so that the excision is performed on both datasets appropriately. imecOut = imec . saveTransformedDataset ( outPath , 'timeShiftsAP' , timeShifts , ... ); A cell array of npxutils.TimeShiftSpec instances can be provided when concatenating multiple files: imecOut = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( outPath , imecList , ... 'timeShiftsAP' , { timeShift1 , timeShift2 , ... }, ...);","title":"Excising time windows"},{"location":"publish/md/ex02_imecdataset.html#referring-to-source-datasets","text":"If helpful, when loading a derived ImecDataset , you can specify the sourceDatasets parameter to provide an array of ImecDataset instances corresponding to the original, pre-processed source datasets. Here, this would be the set of raw datasets provided as the imecList argument above. For certain methods, you can then pass parameter fromSourceDatasets , true and the corresponding window of time from the source datasets will be plotted instead of the processed data. This will automatically handle any time shifts and excisions performed; consequently it is helpful for debugging processing pipelines to see the before and after data. imecProcessed = npxutils . ImecDataset . writeConcatenatedFileMatchGains ( outPath , imecList ); % ... or: imecProcessedB = npxutils . ImecDataset ( outPath , 'sourceDatasets' , { imecRaw1 , imecRaw2 }); imecProcessed . inspectAP_timeWindow ([ 1 2 ], 'fromSourceDatasets' , true );","title":"Referring to Source Datasets"},{"location":"publish/md/ex03_running_kilosort.html","text":"Running Kilosort 1 or 2 and loading the results \u00b6 KilosortDataset is a wrapper around the output of Kilosort or Kilosort2, which will load the output files back into Matlab for further analysis. Most of these fields are explained in detail in the Phy documentation but we document them here for convenience. Running Kilosort \u00b6 To run Kilosort or Kilosort2 on an ImecDataset: npxutils . runKilosort1 ( imec , ... ); Or for Kilosort 2: npxutils . runKilosort2 ( imec , ... ); By default, the standard configuration settings will be used. For Kilosort1, these are hardcoded based on configFiles/StandardConfig_MOVEME.m . For Kilosort2, the script configFiles/configFile384.m will be run to produce the ops struct, unless a different configuration file is set in the environment variable KILOSORT_CONFIG_FILE , which must be on the path. Default configuration settings can be overridden by passing in extra parameters, e.g.: npxutils . runKilosort1 ( imec , 'Th' , [ 4 10 ], 'GPU' , false ); npxutils . runKilosort2 ( imec , 'minfr_goodchannels' , 0.1 ); Loading Kilosort results \u00b6 You can create a KilosortDataset instance by pointing at the folder containing the Kilosort output: ks = npxutils . KilosortDataset ( pathToKilosortOutput (); ks . load (); The constructor will optionally take an \u2018imecDataset\u2019 parameter providing the npxutils.ImecDataset instance if there is no .imec.ap.bin file in the Kilosort directory, and a \u2018channelMap\u2019 parameter in case the default is not correct. The results can then be loaded using ks.load() . The descriptions of each property can be found in the +Neuropixel/KilosortDataset.m code, copied here for convenience, originally described in the Phy documentation : ks nChannels : number of channels used by Kilosort nSpikes : number of spikes extracted nClusters : number of unique clusters nTemplates : number of spike templates nPCFeatures number of spatiotemporal PC features used for templates nFeaturesPerChannel : number of PC features used for each channel amplitudes - [nSpikes] double vector with the amplitude scaling factor that was applied to the template when extracting that spike channel_ids - [nChannels] uint32 vector with the channel ids used for sorting channel_positions - [nChannels, 2] double matrix with each row giving the x and y coordinates of that channel. Together with the channel map, this determines how waveforms will be plotted in WaveformView (see below). pc_features - [nSpikes, nFeaturesPerChannel, nPCFeatures] single matrix giving the PC values for each spike. The channels that those features came from are specified in pc_features_ind. E.g. the value at pc_features[123, 1, 5] is the projection of the 123rd spike onto the 1st PC on the channel given by pc_feature_ind[5]. pc_feature_ind - [nTemplates, nPCFeatures] uint32 matrix specifying which channels contribute to each entry in dim 3 of the pc_features matrix similar_templates - [nTemplates, nTemplates] single matrix giving the similarity score (larger is more similar) between each pair of templates similar_templates(:, :) single spike_templates - [nSpikes] uint32 vector specifying the identity of the template that was used to extract each spike spike_times - [nSpikes] uint64 vector giving the spike time of each spike in samples. To convert to seconds, divide by sample_rate from params.py. template_features - [nSpikes, nTempFeatures] single matrix giving the magnitude of the projection of each spike onto nTempFeatures other features. Which other features is specified in template_feature_ind. template_feature_ind - [nTemplates, nTempFeatures] uint32 matrix specifying which templateFeatures are included in the template_features matrix. templates - [nTemplates, nTimePoints, nTemplateChannels] single matrix giving the template shapes on the channels given in templates_ind templates_ind - [nTemplates, nTempChannels] double matrix specifying the channels on which each template is defined. In the case of Kilosort templates_ind is just the integers from 0 to nChannels-1, since templates are defined on all channels. whitening_mat - [nChannels, nChannels] double whitening matrix applied to the data during automatic spike sorting whitening_mat_inv - [nChannels, nChannels] double, the inverse of the whitening matrix. spike_clusters - [nSpikes] uint32 vector giving the cluster identity of each spike. cluster_groups - [nClusters] categorical vector giving the \u201ccluster group\u201d of each cluster (noise, mua, good, unsorted) cluster_ids - [nClusters] unique clusters in spike_clusters Segmenting a Kilosort dataset into trials \u00b6 ks.spike_times contains the times for each spike in samples from the beginning of the file, but there is a more useful representation for data collected with a trial structure: split the spikes into separate groups based on which trial they occurred in, and convert the times to milliseconds since the start of the trial. TrialSegmentationInfo \u00b6 In order to do this, you need to figure out where trials start and stop. You\u2019ll need to write this code, since this will differ for each experimental setup. Essentially, you need to create a npxutils.TrialSegmentationInfo instance and populate its fields with the correct values: tsi = npxutils . TrialSegmentationInfo ( nTrials , fsAP ); tsi . idxStart = [ list of start sample indices ] tsi . idxStop = [ list of stop sample indices ]; tsi . trialId = [ list of trial ids ]; Here is an example script that uses the sync channel to determine where trials begin and end. It expects one bit (named 'trialStart' ) to contain TTL pulses each time a trial starts, and another bit (named 'trialInfo' ) to contain ASCII-serialized bits of text occurring at the start of each trial. For example, the string id=1;c=2 would correspond to trialId=1 and conditionId=2 . It also assumes that a trial ends when the next trial begins (or at the end of the file). Long trials can be subsequently truncated using tsi.truncateTrialsLongerThan(maxDurationSeconds) . function tsi = parseTrialInfoFromSync ( syncRaw, fs, syncBitNames ) % fs is in samples per second % parses the sync line of an neuropixel .imec.ap.bin data file % and produces a scalar TrialSegmentationInfo % parse the sync if isempty ( syncBitNames ) trialInfoBitNum = 1 ; trialStartBitNum = 2 ; else [ tf , trialInfoBitNum ] = ismember ( 'trialInfo' , syncBitNames ); if ~ tf , trialInfoBitNum = 1 ; end [ tf , trialStartBitNum ] = ismember ( 'trialStart' , syncBitNames ); if ~ tf , trialStartBitNum = 1 ; end end serialBit = bitget ( syncRaw , trialInfoBitNum ); trialStart = bitget ( syncRaw , trialStartBitNum ); % trials start when going high idxStart = find ( diff ( trialStart ) == 1 ) + 1 ; nTrials = numel ( idxStart ); tsi = npxutils . TrialSegmentationInfo ( nTrials , fs ); samplesEachBit = round ( fs / 1000 ); % each bit delivered per ms for iR = 1 : nTrials if iR < nTrials idxNext = idxStart ( iR + 1 ) - 1 ; else idxNext = numel ( serialBit ); end bitsByTrial = uint8 ( serialBit ( floor ( samplesEachBit / 2 ) + idxStart ( iR ) : samplesEachBit : idxNext )); lastHigh = find ( bitsByTrial , 1 , 'last' ); lastHigh = ceil ( lastHigh / 8 ) * 8 ; bitsByTrial = bitsByTrial ( 1 : lastHigh ); infoThis = parseInfoString ( bitsToString ( bitsByTrial )); if isfield ( infoThis , 'id' ) tsi . trialId ( iR ) = str2double ( infoThis . id ); %#ok<*AGROW> else tsi . trialId ( iR ) = NaN ; end if isfield ( infoThis , 'c' ) tsi . conditionId ( iR ) = str2double ( infoThis . c ); else tsi . conditionId ( iR ) = NaN ; end tsi . idxStart ( iR ) = idxStart ( iR ); tsi . idxStop ( iR ) = idxNext ; end function out = bitsToString ( bits ) nChar = numel ( bits ) / 8 ; assert ( nChar == round ( nChar ), 'Bit length must be multiple of 8' ); out = blanks ( nChar ); for iC = 1 : nChar idx = ( 1 : 8 ) + ( iC - 1 ) * 8 ; out ( iC ) = char ( bin2dec ( sprintf ( '%u' , bits ( idx )))); end end function out = parseInfoString ( str ) keyval = regexp ( str , '(?<key>\\w+)=(?<value>[\\d\\.]+)' , 'names' ); if isempty ( keyval ) warning ( 'Could not parse info string \"%s\"' , str ); out = struct (); else for i = 1 : numel ( keyval ) out .( keyval ( i ). key ) = keyval ( i ). value ; end end end end KilosortTrialSegmentedDataset Once you have the trial boundaries stored in your TrialSegmentationInfo instance, you can split the properties of the KilosortDataset into each trial, resulting in a npxutils.KilosortTrialSegmentedDataset instance. To facilitate merging this into another data structure later, you will need to specify the ultimate trialId order you want the KilosortTrialSegmentedDataset to have. For example, if you have a behavioral data structure, you can extract the list of trial ids from that so that your KilosortTrialSegmentedDataset will have a matching trial sequence. trialIds = cat ( 1 , behaviorStruct . trialId ); Any trials not found in the TrialSegmentationInfo will simply be empty in the KilosortTrialSegmentedDataset . If you simply want to preserve the trials in the order they are in tsi , you can simply use: trialIdsB = tsi . trialIds ; You can then segment the KilosortDataset using: seg = npxutils . KilosortTrialSegmentedDataset ( ks , tsi , trial_ids )","title":"Running Kilosort 1 or 2 and loading the results"},{"location":"publish/md/ex03_running_kilosort.html#running-kilosort-1-or-2-and-loading-the-results","text":"KilosortDataset is a wrapper around the output of Kilosort or Kilosort2, which will load the output files back into Matlab for further analysis. Most of these fields are explained in detail in the Phy documentation but we document them here for convenience.","title":"Running Kilosort 1 or 2 and loading the results"},{"location":"publish/md/ex03_running_kilosort.html#running-kilosort","text":"To run Kilosort or Kilosort2 on an ImecDataset: npxutils . runKilosort1 ( imec , ... ); Or for Kilosort 2: npxutils . runKilosort2 ( imec , ... ); By default, the standard configuration settings will be used. For Kilosort1, these are hardcoded based on configFiles/StandardConfig_MOVEME.m . For Kilosort2, the script configFiles/configFile384.m will be run to produce the ops struct, unless a different configuration file is set in the environment variable KILOSORT_CONFIG_FILE , which must be on the path. Default configuration settings can be overridden by passing in extra parameters, e.g.: npxutils . runKilosort1 ( imec , 'Th' , [ 4 10 ], 'GPU' , false ); npxutils . runKilosort2 ( imec , 'minfr_goodchannels' , 0.1 );","title":"Running Kilosort"},{"location":"publish/md/ex03_running_kilosort.html#loading-kilosort-results","text":"You can create a KilosortDataset instance by pointing at the folder containing the Kilosort output: ks = npxutils . KilosortDataset ( pathToKilosortOutput (); ks . load (); The constructor will optionally take an \u2018imecDataset\u2019 parameter providing the npxutils.ImecDataset instance if there is no .imec.ap.bin file in the Kilosort directory, and a \u2018channelMap\u2019 parameter in case the default is not correct. The results can then be loaded using ks.load() . The descriptions of each property can be found in the +Neuropixel/KilosortDataset.m code, copied here for convenience, originally described in the Phy documentation : ks nChannels : number of channels used by Kilosort nSpikes : number of spikes extracted nClusters : number of unique clusters nTemplates : number of spike templates nPCFeatures number of spatiotemporal PC features used for templates nFeaturesPerChannel : number of PC features used for each channel amplitudes - [nSpikes] double vector with the amplitude scaling factor that was applied to the template when extracting that spike channel_ids - [nChannels] uint32 vector with the channel ids used for sorting channel_positions - [nChannels, 2] double matrix with each row giving the x and y coordinates of that channel. Together with the channel map, this determines how waveforms will be plotted in WaveformView (see below). pc_features - [nSpikes, nFeaturesPerChannel, nPCFeatures] single matrix giving the PC values for each spike. The channels that those features came from are specified in pc_features_ind. E.g. the value at pc_features[123, 1, 5] is the projection of the 123rd spike onto the 1st PC on the channel given by pc_feature_ind[5]. pc_feature_ind - [nTemplates, nPCFeatures] uint32 matrix specifying which channels contribute to each entry in dim 3 of the pc_features matrix similar_templates - [nTemplates, nTemplates] single matrix giving the similarity score (larger is more similar) between each pair of templates similar_templates(:, :) single spike_templates - [nSpikes] uint32 vector specifying the identity of the template that was used to extract each spike spike_times - [nSpikes] uint64 vector giving the spike time of each spike in samples. To convert to seconds, divide by sample_rate from params.py. template_features - [nSpikes, nTempFeatures] single matrix giving the magnitude of the projection of each spike onto nTempFeatures other features. Which other features is specified in template_feature_ind. template_feature_ind - [nTemplates, nTempFeatures] uint32 matrix specifying which templateFeatures are included in the template_features matrix. templates - [nTemplates, nTimePoints, nTemplateChannels] single matrix giving the template shapes on the channels given in templates_ind templates_ind - [nTemplates, nTempChannels] double matrix specifying the channels on which each template is defined. In the case of Kilosort templates_ind is just the integers from 0 to nChannels-1, since templates are defined on all channels. whitening_mat - [nChannels, nChannels] double whitening matrix applied to the data during automatic spike sorting whitening_mat_inv - [nChannels, nChannels] double, the inverse of the whitening matrix. spike_clusters - [nSpikes] uint32 vector giving the cluster identity of each spike. cluster_groups - [nClusters] categorical vector giving the \u201ccluster group\u201d of each cluster (noise, mua, good, unsorted) cluster_ids - [nClusters] unique clusters in spike_clusters","title":"Loading Kilosort results"},{"location":"publish/md/ex03_running_kilosort.html#segmenting-a-kilosort-dataset-into-trials","text":"ks.spike_times contains the times for each spike in samples from the beginning of the file, but there is a more useful representation for data collected with a trial structure: split the spikes into separate groups based on which trial they occurred in, and convert the times to milliseconds since the start of the trial.","title":"Segmenting a Kilosort dataset into trials"},{"location":"publish/md/ex03_running_kilosort.html#trialsegmentationinfo","text":"In order to do this, you need to figure out where trials start and stop. You\u2019ll need to write this code, since this will differ for each experimental setup. Essentially, you need to create a npxutils.TrialSegmentationInfo instance and populate its fields with the correct values: tsi = npxutils . TrialSegmentationInfo ( nTrials , fsAP ); tsi . idxStart = [ list of start sample indices ] tsi . idxStop = [ list of stop sample indices ]; tsi . trialId = [ list of trial ids ]; Here is an example script that uses the sync channel to determine where trials begin and end. It expects one bit (named 'trialStart' ) to contain TTL pulses each time a trial starts, and another bit (named 'trialInfo' ) to contain ASCII-serialized bits of text occurring at the start of each trial. For example, the string id=1;c=2 would correspond to trialId=1 and conditionId=2 . It also assumes that a trial ends when the next trial begins (or at the end of the file). Long trials can be subsequently truncated using tsi.truncateTrialsLongerThan(maxDurationSeconds) . function tsi = parseTrialInfoFromSync ( syncRaw, fs, syncBitNames ) % fs is in samples per second % parses the sync line of an neuropixel .imec.ap.bin data file % and produces a scalar TrialSegmentationInfo % parse the sync if isempty ( syncBitNames ) trialInfoBitNum = 1 ; trialStartBitNum = 2 ; else [ tf , trialInfoBitNum ] = ismember ( 'trialInfo' , syncBitNames ); if ~ tf , trialInfoBitNum = 1 ; end [ tf , trialStartBitNum ] = ismember ( 'trialStart' , syncBitNames ); if ~ tf , trialStartBitNum = 1 ; end end serialBit = bitget ( syncRaw , trialInfoBitNum ); trialStart = bitget ( syncRaw , trialStartBitNum ); % trials start when going high idxStart = find ( diff ( trialStart ) == 1 ) + 1 ; nTrials = numel ( idxStart ); tsi = npxutils . TrialSegmentationInfo ( nTrials , fs ); samplesEachBit = round ( fs / 1000 ); % each bit delivered per ms for iR = 1 : nTrials if iR < nTrials idxNext = idxStart ( iR + 1 ) - 1 ; else idxNext = numel ( serialBit ); end bitsByTrial = uint8 ( serialBit ( floor ( samplesEachBit / 2 ) + idxStart ( iR ) : samplesEachBit : idxNext )); lastHigh = find ( bitsByTrial , 1 , 'last' ); lastHigh = ceil ( lastHigh / 8 ) * 8 ; bitsByTrial = bitsByTrial ( 1 : lastHigh ); infoThis = parseInfoString ( bitsToString ( bitsByTrial )); if isfield ( infoThis , 'id' ) tsi . trialId ( iR ) = str2double ( infoThis . id ); %#ok<*AGROW> else tsi . trialId ( iR ) = NaN ; end if isfield ( infoThis , 'c' ) tsi . conditionId ( iR ) = str2double ( infoThis . c ); else tsi . conditionId ( iR ) = NaN ; end tsi . idxStart ( iR ) = idxStart ( iR ); tsi . idxStop ( iR ) = idxNext ; end function out = bitsToString ( bits ) nChar = numel ( bits ) / 8 ; assert ( nChar == round ( nChar ), 'Bit length must be multiple of 8' ); out = blanks ( nChar ); for iC = 1 : nChar idx = ( 1 : 8 ) + ( iC - 1 ) * 8 ; out ( iC ) = char ( bin2dec ( sprintf ( '%u' , bits ( idx )))); end end function out = parseInfoString ( str ) keyval = regexp ( str , '(?<key>\\w+)=(?<value>[\\d\\.]+)' , 'names' ); if isempty ( keyval ) warning ( 'Could not parse info string \"%s\"' , str ); out = struct (); else for i = 1 : numel ( keyval ) out .( keyval ( i ). key ) = keyval ( i ). value ; end end end end KilosortTrialSegmentedDataset Once you have the trial boundaries stored in your TrialSegmentationInfo instance, you can split the properties of the KilosortDataset into each trial, resulting in a npxutils.KilosortTrialSegmentedDataset instance. To facilitate merging this into another data structure later, you will need to specify the ultimate trialId order you want the KilosortTrialSegmentedDataset to have. For example, if you have a behavioral data structure, you can extract the list of trial ids from that so that your KilosortTrialSegmentedDataset will have a matching trial sequence. trialIds = cat ( 1 , behaviorStruct . trialId ); Any trials not found in the TrialSegmentationInfo will simply be empty in the KilosortTrialSegmentedDataset . If you simply want to preserve the trials in the order they are in tsi , you can simply use: trialIdsB = tsi . trialIds ; You can then segment the KilosortDataset using: seg = npxutils . KilosortTrialSegmentedDataset ( ks , tsi , trial_ids )","title":"TrialSegmentationInfo"},{"location":"publish/md/tutorial.html","text":"Startup \u00b6 Edit this to point at the path to where you installed the neuropixel-utils distribution or repo. % Load the Neuropixel Utils library homeDir = string ( java . lang . System . getProperty ( 'user.home' )); npixUtilsDistRoot = fullfile ( homeDir , 'local' , 'repos' , 'npxutils-apj-wip-01' ); addpath ( fullfile ( npixUtilsDistRoot , 'Mcode' )); fprintf ( 'Loaded Neuropixel Utils %s\\n' , npxutils . globals . version ) Loaded Neuropixel Utils 0.5.0-SNAPSHOT Set the default channel map file you want to use with your data. Some standard channel maps are included in the map_files directory in the neuropixel-utils distribution. setenv ( 'NEUROPIXEL_MAP_FILE' , fullfile ( npxutils . globals . distroot , 'map_files' , 'neuropixPhase3A_kilosortChanMap.mat' )) Optional: Configure Neuropixel Utils to generate paths beneath your data root directory, based on its naming conventions. This is entirely optional; you can arrange your data however you\u2019d like. myExampleDataDir = fullfile ( homeDir , 'work' , 'npxutils' , 'example-data' ); setenv ( 'NEUROPIXEL_DATAROOT' , myExampleDataDir ) Load Raw Imec dataset \u00b6 Here we construct the path to the original, raw dataset as it was recorded by SpikeGLX. You don\u2019t need to use this folder nesting structure. subject = 'Vinnie' ; dateStr = '2018-08-17' ; rawBinFile = 'Vinnie_20180817_All.imec.ap.bin' ; imecFile = npxutils . generatePath ( subject , 'raw_datasets' , dateStr , rawBinFile ) imecFile = '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.ap.bin' We then use this path to construct an ImecDataset object which will facilitate access to the raw data and load the metadata from disk. You can pass the path of the Imec dataset in several ways: Path to raw .imec.ap.bin file or imec.lf.bin file. Path to the containing directory, if there is only one set of .bin files within. To construct the ImecDataset object, pass the identifying path directly to the constructor. imec = npxutils . ImecDataset ( imecFile ) imec = ImecDataset with properties: bytesPerSample: 2 pathRoot: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17' fileStem: 'Vinnie_20180817_All' fileImecNumber: NaN creationTime: 7.3729e+05 nChannels: 385 fileTypeAP: 'ap' fileTypeLF: 'lf' nSamplesAP: 36177457 nSamplesLF: 0 fsAP: 30000 fsLF: NaN fsSync: NaN highPassFilterHz: 300 apGain: 500 apRange: [-0.6000 0.6000] lfGain: 250 lfRange: [] adcBits: 10 snsShankMap: \"(1,2,480)(0:0:0:1)(0:1:0:1)(0:0:1:1)(0:1:1:1)(0:0:2:1)(0:1:2:1)(0:0:3:1)(0:1:3:1)(0:0:4:1)(0:1:4:1)(0:0:5:1)(0:1:5:1)(0:0:6:1)(0:1:6:1)(0:0:7:1)(0:1:7:1)(0:0:8:1)(0:1:8:1)(0:0:9:1)(0:1:9:1)(0:0:10:1)(0:1:10:1)(0:0:11:1)(0:1:11:1)(0:0:12:1)(0:1:12:1)(0:0:13:1)(0:1:13:1)(0:0:14:1)(0:1:14:1)(0:0:15:1)(0:1:15:1)(0:0:16:1)(0:1:16:1)(0:0:17:1)(0:1:17:1)(0:0:18:0)(0:1:18:1)(0:0:19:1)(0:1:19:1)(0:0:20:1)(0:1:20:1)(0:0:21:1)(0:1:21:1)(0:0:22:1)(0:1:22:1)(0:0:23:1)(0:1:23:1)(0:0:24:1)(0:1:24:1)(0:0:25:1)(0:1:25:1)(0:0:26:1)(0:1:26:1)(0:0:27:1)(0:1:27:1)(0:0:28:1)(0:1:28:1)(0:0:29:1)(0:1:29:1)(0:0:30:1)(0:1:30:1)(0:0:31:1)(0:1:31:1)(0:0:32:1)(0:1:32:1)(0:0:33:1)(0:1:33:1)(0:0:34:1)(0:1:34:1)(0:0:35:1)(0:1:35:1)(0:0:36:1)(0:1:36:1)(0:0:37:1)(0:1:37:0)(0:0:38:1)(0:1:38:1)(0:0:39:1)(0:1:39:1)(0:0:40:1)(0:1:40:1)(0:0:41:1)(0:1:41:1)(0:0:42:1)(0:1:42:1)(0:0:43:1)(0:1:43:1)(0:0:44:1)(0:1:44:1)(0:0:45:1)(0:1:45:1)(0:0:46:1)(0:1:46:1)(0:0:47:1)(0:1:47:1)(0:0:48:1)(0:1:48:1)(0:0:49:1)(0:1:49:1)(0:0:50:1)(0:1:50:1)(0:0:51:1)(0:1:51:1)(0:0:52:1)(0:1:52:1)(0:0:53:1)(0:1:53:1)(0:0:54:1)(0:1:54:1)(0:0:55:1)(0:1:55:1)(0:0:56:0)(0:1:56:1)(0:0:57:1)(0:1:57:1)(0:0:58:1)(0:1:58:1)(0:0:59:1)(0:1:59:1)(0:0:60:1)(0:1:60:1)(0:0:61:1)(0:1:61:1)(0:0:62:1)(0:1:62:1)(0:0:63:1)(0:1:63:1)(0:0:64:1)(0:1:64:1)(0:0:65:1)(0:1:65:1)(0:0:66:1)(0:1:66:1)(0:0:67:1)(0:1:67:1)(0:0:68:1)(0:1:68:1)(0:0:69:1)(0:1:69:1)(0:0:70:1)(0:1:70:1)(0:0:71:1)(0:1:71:1)(0:0:72:1)(0:1:72:1)(0:0:73:1)(0:1:73:1)(0:0:74:1)(0:1:74:1)(0:0:75:1)(0:1:75:0)(0:0:76:1)(0:1:76:1)(0:0:77:1)(0:1:77:1)(0:0:78:1)(0:1:78:1)(0:0:79:1)(0:1:79:1)(0:0:80:1)(0:1:80:1)(0:0:81:1)(0:1:81:1)(0:0:82:1)(0:1:82:1)(0:0:83:1)(0:1:83:1)(0:0:84:1)(0:1:84:1)(0:0:85:1)(0:1:85:1)(0:0:86:1)(0:1:86:1)(0:0:87:1)(0:1:87:1)(0:0:88:1)(0:1:88:1)(0:0:89:1)(0:1:89:1)(0:0:90:1)(0:1:90:1)(0:0:91:1)(0:1:91:1)(0:0:92:1)(0:1:92:1)(0:0:93:1)(0:1:93:1)(0:0:94:0)(0:1:94:1)(0:0:95:1)(0:1:95:1)(0:0:96:1)(0:1:96:1)(0:0:97:1)(0:1:97:1)(0:0:98:1)(0:1:98:1)(0:0:99:1)(0:1:99:1)(0:0:100:1)(0:1:100:1)(0:0:101:1)(0:1:101:1)(0:0:102:1)(0:1:102:1)(0:0:103:1)(0:1:103:1)(0:0:104:1)(0:1:104:1)(0:0:105:1)(0:1:105:1)(0:0:106:1)(0:1:106:1)(0:0:107:1)(0:1:107:1)(0:0:108:1)(0:1:108:1)(0:0:109:1)(0:1:109:1)(0:0:110:1)(0:1:110:1)(0:0:111:1)(0:1:111:1)(0:0:112:1)(0:1:112:1)(0:0:113:1)(0:1:113:0)(0:0:114:1)(0:1:114:1)(0:0:115:1)(0:1:115:1)(0:0:116:1)(0:1:116:1)(0:0:117:1)(0:1:117:1)(0:0:118:1)(0:1:118:1)(0:0:119:1)(0:1:119:1)(0:0:120:1)(0:1:120:1)(0:0:121:1)(0:1:121:1)(0:0:122:1)(0:1:122:1)(0:0:123:1)(0:1:123:1)(0:0:124:1)(0:1:124:1)(0:0:125:1)(0:1:125:1)(0:0:126:1)(0:1:126:1)(0:0:127:1)(0:1:127:1)(0:0:128:1)(0:1:128:1)(0:0:129:1)(0:1:129:1)(0:0:130:1)(0:1:130:1)(0:0:131:1)(0:1:131:1)(0:0:132:0)(0:1:132:1)(0:0:133:1)(0:1:133:1)(0:0:134:1)(0:1:134:1)(0:0:135:1)(0:1:135:1)(0:0:136:1)(0:1:136:1)(0:0:137:1)(0:1:137:1)(0:0:138:1)(0:1:138:1)(0:0:139:1)(0:1:139:1)(0:0:140:1)(0:1:140:1)(0:0:141:1)(0:1:141:1)(0:0:142:1)(0:1:142:1)(0:0:143:1)(0:1:143:1)(0:0:144:1)(0:1:144:1)(0:0:145:1)(0:1:145:1)(0:0:146:1)(0:1:146:1)(0:0:147:1)(0:1:147:1)(0:0:148:1)(0:1:148:1)(0:0:149:1)(0:1:149:1)(0:0:150:1)(0:1:150:1)(0:0:151:1)(0:1:151:0)(0:0:152:1)(0:1:152:1)(0:0:153:1)(0:1:153:1)(0:0:154:1)(0:1:154:1)(0:0:155:1)(0:1:155:1)(0:0:156:1)(0:1:156:1)(0:0:157:1)(0:1:157:1)(0:0:158:1)(0:1:158:1)(0:0:159:1)(0:1:159:1)(0:0:160:1)(0:1:160:1)(0:0:161:1)(0:1:161:1)(0:0:162:1)(0:1:162:1)(0:0:163:1)(0:1:163:1)(0:0:164:1)(0:1:164:1)(0:0:165:1)(0:1:165:1)(0:0:166:1)(0:1:166:1)(0:0:167:1)(0:1:167:1)(0:0:168:1)(0:1:168:1)(0:0:169:1)(0:1:169:1)(0:0:170:0)(0:1:170:1)(0:0:171:1)(0:1:171:1)(0:0:172:1)(0:1:172:1)(0:0:173:1)(0:1:173:1)(0:0:174:1)(0:1:174:1)(0:0:175:1)(0:1:175:1)(0:0:176:1)(0:1:176:1)(0:0:177:1)(0:1:177:1)(0:0:178:1)(0:1:178:1)(0:0:179:1)(0:1:179:1)(0:0:180:1)(0:1:180:1)(0:0:181:1)(0:1:181:1)(0:0:182:1)(0:1:182:1)(0:0:183:1)(0:1:183:1)(0:0:184:1)(0:1:184:1)(0:0:185:1)(0:1:185:1)(0:0:186:1)(0:1:186:1)(0:0:187:1)(0:1:187:1)(0:0:188:1)(0:1:188:1)(0:0:189:1)(0:1:189:0)(0:0:190:1)(0:1:190:1)(0:0:191:1)(0:1:191:1)\" channelMap: [1x1 npxutils.ChannelMap] badChannels: [0x1 uint32] syncBitNames: [16x1 string] concatenationInfoAP: [1x1 npxutils.ConcatenationInfo] concatenationInfoLF: [] sourceDatasets: [] syncRaw: [] hasAP: 1 hasLF: 0 hasSourceDatasets: 0 hasSourceAP: 0 hasSourceLF: 0 hasSourceSync: 0 channelMapFile: \"/home/janke/local/repos/npxutils-apj-wip-01/map_files/neuropixPhase3A_kilosortChanMap.mat\" mappedChannels: [384x1 uint32] mappedChannelInds: [384x1 double] nChannelsMapped: 384 connectedChannels: [374x1 uint32] connectedChannelInds: [374x1 double] nChannelsConnected: 374 goodChannels: [374x1 uint32] goodChannelInds: [374x1 double] nGoodChannels: 374 channelIds: [385x1 uint32] channelNames: [385x1 string] channelNamesPadded: [385x1 string] nSyncBits: 16 syncBitsNamed: [11x1 double] fileAP: 'Vinnie_20180817_All.imec.ap.bin' pathAP: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.ap.bin' fileAPMeta: 'Vinnie_20180817_All.imec.ap.meta' pathAPMeta: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.ap.meta' fileLF: 'Vinnie_20180817_All.imec.lf.bin' pathLF: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.lf.bin' fileLFMeta: 'Vinnie_20180817_All.imec.lf.meta' pathLFMeta: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.lf.meta' fileSync: 'Vinnie_20180817_All.imec.ap.bin' pathSync: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.ap.bin' fileSyncCached: 'Vinnie_20180817_All.sync.mat' pathSyncCached: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.sync.mat' creationTimeStr: '17-Aug-2018 13:50:34' apScaleToUv: 2.3438 lfScaleToUv: NaN syncChannelId: 385 syncChannelIndex: 385 syncInAPFile: 1 syncInLFFile: 0 Specifying the channel map manually \u00b6 By default, the channel map will be loaded from whatever the environment variable NEUROPIXEL_MAP_FILE is set to, which we set above. If you want to manaully specify a channel map, pass it in to the ImecDataset constructor using the channelMap option: imec = npxutils.ImecDataset(imecFile, \u2018channelMap\u2019, \u2018/path/to/channelMap.mat\u2019); Explore the loaded metadata \u00b6 Here we see that this option 3A probe has 384 total channels (saved in the .imec.ap.bin file), and that 374 of these channels are connected, namely those listed in connectedChannels . imec . channelMap ans = ChannelMap with properties: file: \"/home/janke/local/repos/npxutils-apj-wip-01/map_files/neuropixPhase3A_kilosortChanMap.mat\" name: \"neuropixPhase3A_kilosortChanMap\" channelIdsMapped: [384x1 uint32] connected: [384x1 logical] shankInd: [384x1 double] nSpatialDims: 2 xcoords: [384x1 double] ycoords: [384x1 double] zcoords: [384x1 double] syncChannelIndex: 385 syncChannelId: 385 coords: [384x2 double] syncInAPFile: 1 syncInLFFile: 1 channelIds: [385x1 uint32] nChannels: 385 nChannelsMapped: 384 connectedChannels: [374x1 uint32] referenceChannels: [10x1 uint32] invertChannelsY: 1 yspacing: 20 xspacing: 16 zspacing: [0x1 double] xlim: [-9 79] ylim: [0 3860] We can determine the duration of the recording using the number of samples and the frequency in the Imec data: durationMinutes = imec . nSamplesAP / imec . fsAP / 60 ; fprintf ( 'Duration of recording %s is %.1f minutes.\\n' , imec . fileStem , durationMinutes ) Duration of recording Vinnie_20180817_All is 20.1 minutes. Accessing the raw AP data \u00b6 You can access the raw AP data in several ways. (See the full list of methods with methods(imec) or doc npxutils.ImecDataset ). The most straightforward is to memory-map the full binary data: This bit is broken because it references code that doesn\u2019t exist in this library. Probably left over from an older version of the library and never updated? Or maybe it has an external dependency? % This is broken because NeuropixelExpt doesn't exist? % NeuropixelExpt.DataLoad.setImecSyncBitNames(imec); % What does \"p\" refer to here? % if ~isempty(p.Results.badChannels) % imec.markBadChannels(p.Results.badChannels); % end This stuff works: rmsBadChannels = imec . markBadChannelsByRMS ( 'rmsRange' , [ 3 100 ]); fprintf ( 'Marked %d channels bad based on RMS\\n' , numel ( rmsBadChannels )); Marked 0 channels bad based on RMS % Save the bad channels and sync bit names back to the meta file imec . writeModifiedAPMeta (); % CAR the file and flush the unused sync bits to the cleaned_datasets folder cleanedBinFile = 'Vinnie_20180817_All_cleaned.imec.ap.bin' cleanedBinFile = 'Vinnie_20180817_All_cleaned.imec.ap.bin' cleanedPath = npxutils . generatePath ( subject , 'cleaned_datasets' , dateStr , cleanedBinFile ); fprintf ( 'Writing CAR version at %s\\n' , cleanedPath ); Writing CAR version at /home/janke/work/npxutils/example-data/Vinnie/cleaned_datasets/2018-08-17/Vinnie_20180817_All_cleaned.imec.ap.bin extraMeta = struct ; extraMeta . run_clearUnusedSyncBits = true ; extraMeta . run_detectAndMarkStimArtifactWindows = true ; fnList = { % This is broken because NeuropixelExpt doesn't exist? % @NeuropixelExpt.DataClean.clearUnusedSyncBits @ npxutils . dataprocess . commonAverageReference } '; cleanedDataDir = fullfile(myExampleDataDir, ' Vinnie ' , 'cleaned_datasets' ); npxutils . io . rmrf ( cleanedDataDir ); imec = imec . saveTransformedDataset ( cleanedPath , ... 'goodChannelsOnly' , false , 'writeSyncSeparate' , false , ... 'transformAP' , fnList , 'extraMeta' , extraMeta ); Writing AP meta file Vinnie_20180817_All_cleaned.imec.ap.meta Writing AP bin file /home/janke/work/npxutils/example-data/Vinnie/cleaned_datasets/2018-08-17/Vinnie_20180817_All_cleaned.imec.ap.bin Writing contents of Vinnie_20180817_All Copying ap file 1 / 1: Vinnie_20180817_All : 100% [_______________] Warning: AP bin file size is not an integral number of samples, file data may not be fully copied, truncating nSamplesAP Error using npxutils.ConcatenationInfo (line 56) Mismatch between time shifts and total number of samples Error in npxutils.ImecDataset/readInfo (line 313) this.concatenationInfoAP = npxutils.ConcatenationInfo(this, 'ap', metaAP); Error in npxutils.ImecDataset (line 193) this.readInfo(); Error in npxutils.ImecDataset.writeConcatenatedFileMatchGains (line 2763) imecOut = npxutils.ImecDataset(outFile, 'channelMap', imecList{1}.channelMapFile, 'sourceDatasets', cat(1, imecList{:})); Error in npxutils.ImecDataset/saveTransformedDataset (line 1943) imecOut = npxutils.ImecDataset.writeConcatenatedFileMatchGains({this}, outPath, p.Results); % Symlink into ks directory for Kilosort's use ksPath = npxutils . generatePath ( subject , 'ks' , dateStr , cleanedBinFile ); fprintf ( 'Symlinking to %s\\n' , ksPath ); % And run Kilosort on the symlinked data set imec = imec . symLinkAPIntoDirectory ( ksPath ); fprintf ( 'Running Kilosort2\\n' ); npxutils . runKilosort2 ( imec ); % Here's a little summary output info . rawPath = imecFile ; info . cleanedPath = cleanedPath ; info . ksPath = ksPath ; info","title":"Tutorial (Markdown)"},{"location":"publish/md/tutorial.html#startup","text":"Edit this to point at the path to where you installed the neuropixel-utils distribution or repo. % Load the Neuropixel Utils library homeDir = string ( java . lang . System . getProperty ( 'user.home' )); npixUtilsDistRoot = fullfile ( homeDir , 'local' , 'repos' , 'npxutils-apj-wip-01' ); addpath ( fullfile ( npixUtilsDistRoot , 'Mcode' )); fprintf ( 'Loaded Neuropixel Utils %s\\n' , npxutils . globals . version ) Loaded Neuropixel Utils 0.5.0-SNAPSHOT Set the default channel map file you want to use with your data. Some standard channel maps are included in the map_files directory in the neuropixel-utils distribution. setenv ( 'NEUROPIXEL_MAP_FILE' , fullfile ( npxutils . globals . distroot , 'map_files' , 'neuropixPhase3A_kilosortChanMap.mat' )) Optional: Configure Neuropixel Utils to generate paths beneath your data root directory, based on its naming conventions. This is entirely optional; you can arrange your data however you\u2019d like. myExampleDataDir = fullfile ( homeDir , 'work' , 'npxutils' , 'example-data' ); setenv ( 'NEUROPIXEL_DATAROOT' , myExampleDataDir )","title":"Startup"},{"location":"publish/md/tutorial.html#load-raw-imec-dataset","text":"Here we construct the path to the original, raw dataset as it was recorded by SpikeGLX. You don\u2019t need to use this folder nesting structure. subject = 'Vinnie' ; dateStr = '2018-08-17' ; rawBinFile = 'Vinnie_20180817_All.imec.ap.bin' ; imecFile = npxutils . generatePath ( subject , 'raw_datasets' , dateStr , rawBinFile ) imecFile = '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.ap.bin' We then use this path to construct an ImecDataset object which will facilitate access to the raw data and load the metadata from disk. You can pass the path of the Imec dataset in several ways: Path to raw .imec.ap.bin file or imec.lf.bin file. Path to the containing directory, if there is only one set of .bin files within. To construct the ImecDataset object, pass the identifying path directly to the constructor. imec = npxutils . ImecDataset ( imecFile ) imec = ImecDataset with properties: bytesPerSample: 2 pathRoot: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17' fileStem: 'Vinnie_20180817_All' fileImecNumber: NaN creationTime: 7.3729e+05 nChannels: 385 fileTypeAP: 'ap' fileTypeLF: 'lf' nSamplesAP: 36177457 nSamplesLF: 0 fsAP: 30000 fsLF: NaN fsSync: NaN highPassFilterHz: 300 apGain: 500 apRange: [-0.6000 0.6000] lfGain: 250 lfRange: [] adcBits: 10 snsShankMap: \"(1,2,480)(0:0:0:1)(0:1:0:1)(0:0:1:1)(0:1:1:1)(0:0:2:1)(0:1:2:1)(0:0:3:1)(0:1:3:1)(0:0:4:1)(0:1:4:1)(0:0:5:1)(0:1:5:1)(0:0:6:1)(0:1:6:1)(0:0:7:1)(0:1:7:1)(0:0:8:1)(0:1:8:1)(0:0:9:1)(0:1:9:1)(0:0:10:1)(0:1:10:1)(0:0:11:1)(0:1:11:1)(0:0:12:1)(0:1:12:1)(0:0:13:1)(0:1:13:1)(0:0:14:1)(0:1:14:1)(0:0:15:1)(0:1:15:1)(0:0:16:1)(0:1:16:1)(0:0:17:1)(0:1:17:1)(0:0:18:0)(0:1:18:1)(0:0:19:1)(0:1:19:1)(0:0:20:1)(0:1:20:1)(0:0:21:1)(0:1:21:1)(0:0:22:1)(0:1:22:1)(0:0:23:1)(0:1:23:1)(0:0:24:1)(0:1:24:1)(0:0:25:1)(0:1:25:1)(0:0:26:1)(0:1:26:1)(0:0:27:1)(0:1:27:1)(0:0:28:1)(0:1:28:1)(0:0:29:1)(0:1:29:1)(0:0:30:1)(0:1:30:1)(0:0:31:1)(0:1:31:1)(0:0:32:1)(0:1:32:1)(0:0:33:1)(0:1:33:1)(0:0:34:1)(0:1:34:1)(0:0:35:1)(0:1:35:1)(0:0:36:1)(0:1:36:1)(0:0:37:1)(0:1:37:0)(0:0:38:1)(0:1:38:1)(0:0:39:1)(0:1:39:1)(0:0:40:1)(0:1:40:1)(0:0:41:1)(0:1:41:1)(0:0:42:1)(0:1:42:1)(0:0:43:1)(0:1:43:1)(0:0:44:1)(0:1:44:1)(0:0:45:1)(0:1:45:1)(0:0:46:1)(0:1:46:1)(0:0:47:1)(0:1:47:1)(0:0:48:1)(0:1:48:1)(0:0:49:1)(0:1:49:1)(0:0:50:1)(0:1:50:1)(0:0:51:1)(0:1:51:1)(0:0:52:1)(0:1:52:1)(0:0:53:1)(0:1:53:1)(0:0:54:1)(0:1:54:1)(0:0:55:1)(0:1:55:1)(0:0:56:0)(0:1:56:1)(0:0:57:1)(0:1:57:1)(0:0:58:1)(0:1:58:1)(0:0:59:1)(0:1:59:1)(0:0:60:1)(0:1:60:1)(0:0:61:1)(0:1:61:1)(0:0:62:1)(0:1:62:1)(0:0:63:1)(0:1:63:1)(0:0:64:1)(0:1:64:1)(0:0:65:1)(0:1:65:1)(0:0:66:1)(0:1:66:1)(0:0:67:1)(0:1:67:1)(0:0:68:1)(0:1:68:1)(0:0:69:1)(0:1:69:1)(0:0:70:1)(0:1:70:1)(0:0:71:1)(0:1:71:1)(0:0:72:1)(0:1:72:1)(0:0:73:1)(0:1:73:1)(0:0:74:1)(0:1:74:1)(0:0:75:1)(0:1:75:0)(0:0:76:1)(0:1:76:1)(0:0:77:1)(0:1:77:1)(0:0:78:1)(0:1:78:1)(0:0:79:1)(0:1:79:1)(0:0:80:1)(0:1:80:1)(0:0:81:1)(0:1:81:1)(0:0:82:1)(0:1:82:1)(0:0:83:1)(0:1:83:1)(0:0:84:1)(0:1:84:1)(0:0:85:1)(0:1:85:1)(0:0:86:1)(0:1:86:1)(0:0:87:1)(0:1:87:1)(0:0:88:1)(0:1:88:1)(0:0:89:1)(0:1:89:1)(0:0:90:1)(0:1:90:1)(0:0:91:1)(0:1:91:1)(0:0:92:1)(0:1:92:1)(0:0:93:1)(0:1:93:1)(0:0:94:0)(0:1:94:1)(0:0:95:1)(0:1:95:1)(0:0:96:1)(0:1:96:1)(0:0:97:1)(0:1:97:1)(0:0:98:1)(0:1:98:1)(0:0:99:1)(0:1:99:1)(0:0:100:1)(0:1:100:1)(0:0:101:1)(0:1:101:1)(0:0:102:1)(0:1:102:1)(0:0:103:1)(0:1:103:1)(0:0:104:1)(0:1:104:1)(0:0:105:1)(0:1:105:1)(0:0:106:1)(0:1:106:1)(0:0:107:1)(0:1:107:1)(0:0:108:1)(0:1:108:1)(0:0:109:1)(0:1:109:1)(0:0:110:1)(0:1:110:1)(0:0:111:1)(0:1:111:1)(0:0:112:1)(0:1:112:1)(0:0:113:1)(0:1:113:0)(0:0:114:1)(0:1:114:1)(0:0:115:1)(0:1:115:1)(0:0:116:1)(0:1:116:1)(0:0:117:1)(0:1:117:1)(0:0:118:1)(0:1:118:1)(0:0:119:1)(0:1:119:1)(0:0:120:1)(0:1:120:1)(0:0:121:1)(0:1:121:1)(0:0:122:1)(0:1:122:1)(0:0:123:1)(0:1:123:1)(0:0:124:1)(0:1:124:1)(0:0:125:1)(0:1:125:1)(0:0:126:1)(0:1:126:1)(0:0:127:1)(0:1:127:1)(0:0:128:1)(0:1:128:1)(0:0:129:1)(0:1:129:1)(0:0:130:1)(0:1:130:1)(0:0:131:1)(0:1:131:1)(0:0:132:0)(0:1:132:1)(0:0:133:1)(0:1:133:1)(0:0:134:1)(0:1:134:1)(0:0:135:1)(0:1:135:1)(0:0:136:1)(0:1:136:1)(0:0:137:1)(0:1:137:1)(0:0:138:1)(0:1:138:1)(0:0:139:1)(0:1:139:1)(0:0:140:1)(0:1:140:1)(0:0:141:1)(0:1:141:1)(0:0:142:1)(0:1:142:1)(0:0:143:1)(0:1:143:1)(0:0:144:1)(0:1:144:1)(0:0:145:1)(0:1:145:1)(0:0:146:1)(0:1:146:1)(0:0:147:1)(0:1:147:1)(0:0:148:1)(0:1:148:1)(0:0:149:1)(0:1:149:1)(0:0:150:1)(0:1:150:1)(0:0:151:1)(0:1:151:0)(0:0:152:1)(0:1:152:1)(0:0:153:1)(0:1:153:1)(0:0:154:1)(0:1:154:1)(0:0:155:1)(0:1:155:1)(0:0:156:1)(0:1:156:1)(0:0:157:1)(0:1:157:1)(0:0:158:1)(0:1:158:1)(0:0:159:1)(0:1:159:1)(0:0:160:1)(0:1:160:1)(0:0:161:1)(0:1:161:1)(0:0:162:1)(0:1:162:1)(0:0:163:1)(0:1:163:1)(0:0:164:1)(0:1:164:1)(0:0:165:1)(0:1:165:1)(0:0:166:1)(0:1:166:1)(0:0:167:1)(0:1:167:1)(0:0:168:1)(0:1:168:1)(0:0:169:1)(0:1:169:1)(0:0:170:0)(0:1:170:1)(0:0:171:1)(0:1:171:1)(0:0:172:1)(0:1:172:1)(0:0:173:1)(0:1:173:1)(0:0:174:1)(0:1:174:1)(0:0:175:1)(0:1:175:1)(0:0:176:1)(0:1:176:1)(0:0:177:1)(0:1:177:1)(0:0:178:1)(0:1:178:1)(0:0:179:1)(0:1:179:1)(0:0:180:1)(0:1:180:1)(0:0:181:1)(0:1:181:1)(0:0:182:1)(0:1:182:1)(0:0:183:1)(0:1:183:1)(0:0:184:1)(0:1:184:1)(0:0:185:1)(0:1:185:1)(0:0:186:1)(0:1:186:1)(0:0:187:1)(0:1:187:1)(0:0:188:1)(0:1:188:1)(0:0:189:1)(0:1:189:0)(0:0:190:1)(0:1:190:1)(0:0:191:1)(0:1:191:1)\" channelMap: [1x1 npxutils.ChannelMap] badChannels: [0x1 uint32] syncBitNames: [16x1 string] concatenationInfoAP: [1x1 npxutils.ConcatenationInfo] concatenationInfoLF: [] sourceDatasets: [] syncRaw: [] hasAP: 1 hasLF: 0 hasSourceDatasets: 0 hasSourceAP: 0 hasSourceLF: 0 hasSourceSync: 0 channelMapFile: \"/home/janke/local/repos/npxutils-apj-wip-01/map_files/neuropixPhase3A_kilosortChanMap.mat\" mappedChannels: [384x1 uint32] mappedChannelInds: [384x1 double] nChannelsMapped: 384 connectedChannels: [374x1 uint32] connectedChannelInds: [374x1 double] nChannelsConnected: 374 goodChannels: [374x1 uint32] goodChannelInds: [374x1 double] nGoodChannels: 374 channelIds: [385x1 uint32] channelNames: [385x1 string] channelNamesPadded: [385x1 string] nSyncBits: 16 syncBitsNamed: [11x1 double] fileAP: 'Vinnie_20180817_All.imec.ap.bin' pathAP: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.ap.bin' fileAPMeta: 'Vinnie_20180817_All.imec.ap.meta' pathAPMeta: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.ap.meta' fileLF: 'Vinnie_20180817_All.imec.lf.bin' pathLF: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.lf.bin' fileLFMeta: 'Vinnie_20180817_All.imec.lf.meta' pathLFMeta: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.lf.meta' fileSync: 'Vinnie_20180817_All.imec.ap.bin' pathSync: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.imec.ap.bin' fileSyncCached: 'Vinnie_20180817_All.sync.mat' pathSyncCached: '/home/janke/work/npxutils/example-data/Vinnie/raw_datasets/2018-08-17/Vinnie_20180817_All.sync.mat' creationTimeStr: '17-Aug-2018 13:50:34' apScaleToUv: 2.3438 lfScaleToUv: NaN syncChannelId: 385 syncChannelIndex: 385 syncInAPFile: 1 syncInLFFile: 0","title":"Load Raw Imec dataset"},{"location":"publish/md/tutorial.html#specifying-the-channel-map-manually","text":"By default, the channel map will be loaded from whatever the environment variable NEUROPIXEL_MAP_FILE is set to, which we set above. If you want to manaully specify a channel map, pass it in to the ImecDataset constructor using the channelMap option: imec = npxutils.ImecDataset(imecFile, \u2018channelMap\u2019, \u2018/path/to/channelMap.mat\u2019);","title":"Specifying the channel map manually"},{"location":"publish/md/tutorial.html#explore-the-loaded-metadata","text":"Here we see that this option 3A probe has 384 total channels (saved in the .imec.ap.bin file), and that 374 of these channels are connected, namely those listed in connectedChannels . imec . channelMap ans = ChannelMap with properties: file: \"/home/janke/local/repos/npxutils-apj-wip-01/map_files/neuropixPhase3A_kilosortChanMap.mat\" name: \"neuropixPhase3A_kilosortChanMap\" channelIdsMapped: [384x1 uint32] connected: [384x1 logical] shankInd: [384x1 double] nSpatialDims: 2 xcoords: [384x1 double] ycoords: [384x1 double] zcoords: [384x1 double] syncChannelIndex: 385 syncChannelId: 385 coords: [384x2 double] syncInAPFile: 1 syncInLFFile: 1 channelIds: [385x1 uint32] nChannels: 385 nChannelsMapped: 384 connectedChannels: [374x1 uint32] referenceChannels: [10x1 uint32] invertChannelsY: 1 yspacing: 20 xspacing: 16 zspacing: [0x1 double] xlim: [-9 79] ylim: [0 3860] We can determine the duration of the recording using the number of samples and the frequency in the Imec data: durationMinutes = imec . nSamplesAP / imec . fsAP / 60 ; fprintf ( 'Duration of recording %s is %.1f minutes.\\n' , imec . fileStem , durationMinutes ) Duration of recording Vinnie_20180817_All is 20.1 minutes.","title":"Explore the loaded metadata"},{"location":"publish/md/tutorial.html#accessing-the-raw-ap-data","text":"You can access the raw AP data in several ways. (See the full list of methods with methods(imec) or doc npxutils.ImecDataset ). The most straightforward is to memory-map the full binary data: This bit is broken because it references code that doesn\u2019t exist in this library. Probably left over from an older version of the library and never updated? Or maybe it has an external dependency? % This is broken because NeuropixelExpt doesn't exist? % NeuropixelExpt.DataLoad.setImecSyncBitNames(imec); % What does \"p\" refer to here? % if ~isempty(p.Results.badChannels) % imec.markBadChannels(p.Results.badChannels); % end This stuff works: rmsBadChannels = imec . markBadChannelsByRMS ( 'rmsRange' , [ 3 100 ]); fprintf ( 'Marked %d channels bad based on RMS\\n' , numel ( rmsBadChannels )); Marked 0 channels bad based on RMS % Save the bad channels and sync bit names back to the meta file imec . writeModifiedAPMeta (); % CAR the file and flush the unused sync bits to the cleaned_datasets folder cleanedBinFile = 'Vinnie_20180817_All_cleaned.imec.ap.bin' cleanedBinFile = 'Vinnie_20180817_All_cleaned.imec.ap.bin' cleanedPath = npxutils . generatePath ( subject , 'cleaned_datasets' , dateStr , cleanedBinFile ); fprintf ( 'Writing CAR version at %s\\n' , cleanedPath ); Writing CAR version at /home/janke/work/npxutils/example-data/Vinnie/cleaned_datasets/2018-08-17/Vinnie_20180817_All_cleaned.imec.ap.bin extraMeta = struct ; extraMeta . run_clearUnusedSyncBits = true ; extraMeta . run_detectAndMarkStimArtifactWindows = true ; fnList = { % This is broken because NeuropixelExpt doesn't exist? % @NeuropixelExpt.DataClean.clearUnusedSyncBits @ npxutils . dataprocess . commonAverageReference } '; cleanedDataDir = fullfile(myExampleDataDir, ' Vinnie ' , 'cleaned_datasets' ); npxutils . io . rmrf ( cleanedDataDir ); imec = imec . saveTransformedDataset ( cleanedPath , ... 'goodChannelsOnly' , false , 'writeSyncSeparate' , false , ... 'transformAP' , fnList , 'extraMeta' , extraMeta ); Writing AP meta file Vinnie_20180817_All_cleaned.imec.ap.meta Writing AP bin file /home/janke/work/npxutils/example-data/Vinnie/cleaned_datasets/2018-08-17/Vinnie_20180817_All_cleaned.imec.ap.bin Writing contents of Vinnie_20180817_All Copying ap file 1 / 1: Vinnie_20180817_All : 100% [_______________] Warning: AP bin file size is not an integral number of samples, file data may not be fully copied, truncating nSamplesAP Error using npxutils.ConcatenationInfo (line 56) Mismatch between time shifts and total number of samples Error in npxutils.ImecDataset/readInfo (line 313) this.concatenationInfoAP = npxutils.ConcatenationInfo(this, 'ap', metaAP); Error in npxutils.ImecDataset (line 193) this.readInfo(); Error in npxutils.ImecDataset.writeConcatenatedFileMatchGains (line 2763) imecOut = npxutils.ImecDataset(outFile, 'channelMap', imecList{1}.channelMapFile, 'sourceDatasets', cat(1, imecList{:})); Error in npxutils.ImecDataset/saveTransformedDataset (line 1943) imecOut = npxutils.ImecDataset.writeConcatenatedFileMatchGains({this}, outPath, p.Results); % Symlink into ks directory for Kilosort's use ksPath = npxutils . generatePath ( subject , 'ks' , dateStr , cleanedBinFile ); fprintf ( 'Symlinking to %s\\n' , ksPath ); % And run Kilosort on the symlinked data set imec = imec . symLinkAPIntoDirectory ( ksPath ); fprintf ( 'Running Kilosort2\\n' ); npxutils . runKilosort2 ( imec ); % Here's a little summary output info . rawPath = imecFile ; info . cleanedPath = cleanedPath ; info . ksPath = ksPath ; info","title":"Accessing the raw AP data"}]}